# CSS

1. 如何实现一个元素的水平垂直居中
    1. son：absolute + transform(tanslate(50%, 50%))
    2. container(flex) + son(margin: auto)
    3. container(grid) + son(margin: auto)

2. 响应式布局
    > 主轴和交叉轴都可能有多个

    1. Multicol（多列）
        1. column-count：列数
        2. *-gap：间隙
        3. *-rule：添加分割线
        4. break-inside：多列布局下内容盒子如何中断
    2. Flex Box（弹性盒）
        1. flex-direction\wrap\
        2. flex = grow shrink basis
        3. flex-basis在纵向排列时代表height，为最优选
    3. Grid
        1. 1fr，一份
    4. align-content：分配**多行内容**交叉轴方向剩余空间
    5. justify-content：分配主轴方向剩余空间
    6. justify-items：设置容器内每个元素主轴方向的justify-self
    7. justify-self: 设置元素相对于其交叉轴的对齐方式
    8. align-items: 设置每个元素的align-self
    9.  align-self：设置元素相对于其所在主轴对齐方式
    10. place-content = align-content justify-content
    11. place-items = align-items justify-items
3. 标准盒和怪异盒

    content-box'width = content
    border-box'width = border + padding + content

4. FC（文档流，Formatting Context）

    页面中的一块渲染区域，有自己的渲染规则，决定其子元素如何布局以及和其他元素之间的关系和作用。

    1. BFC（区块格式化上下文，Block Formatting Context）（GFC、FFC也是一个BFC）
        
        块级盒子布局时，BFC为其提供隔离环境，使其不影响容器外布局，元素在这个环境中按照一定规则进行布局。

        1. 创建： 根元素、浮动元素、悬浮元素、display: flex\inline-block\table\grid、overflow：hidden|auto|scroll
        2. 特性：
            1. BFC 是一个独立的容器，容器内子元素不会影响容器外的元素。反之亦如此。
            2. 盒子遵照一些规则有序排列
            3. 相邻盒子margin-top-bottom会发生重叠
            4. BFC包含浮动元素时（另一个BFC），浮动元素也会参与区域高度计算
        3. 作用
            1. 清除浮动（或使用clearfix）：浮动元素会覆盖普通文档流，但是不会覆盖BFC
            2. 阻止margin-top\margin-bottom合并：外部元素不会影响BFC布局
            3. 阻止容器高度塌陷：浮动元素参与区域高度计算
    2. IFC（行级格式化上下文）

        行级元素包括：a\img\picture\span\input\select\textarea\label

        1. 创建：块级元素中仅包含行内元素
        2. 特性：
            1. 水平横向排列，垂直方向起点是父元素顶部
            2. 只计算横向样式（ml\mr\pl\pr\border），行高由CSS行高计算规则来确定
            3. 垂直方向可使用（vertical-align）进行布局
            4. 如果宽度小于容器宽度，由text-align决定水平分布，超出容器宽度可以会溢出，可以设置white-wrap换行。

5. CSS伪类和伪元素
    
    伪元素会在文档流生成新的元素，使用content属性可以设置内容

    伪类可以定义元素在不同状态下的样式，或者选择元素（比如：is ：not：has）。

6. CSS样式优先级

    内联样式 > ID选择器 > 类选择器（类、属性选择器、伪类） > 类型选择器（标签、伪元素）

    ！importment会破坏CSS specificity

7. 优化关键渲染路径（css性能优化）
    1. 如果css文件很大，阻塞了渲染，应该对样式表进行拆分。可以通过media告诉浏览器哪些内容在当前渲染中是重要的，不重要的css浏览器也会下载，但是不会阻塞渲染
    2. 将元素提升为图层，使动画转换在GPU上进行，从而提升性能。属性包括：transform、opacity、will-change、filter、animation；相关标签包括：video、canvas、iframe
    3. will-change可以告诉浏览器，元素的哪些属性需要修改，使浏览器提前做出优化

        ```css
        will-change: opactiy, transform;
        ```
    4. font-display：字体包体积比较大，在下载期间需要过渡字体。
    5. contain：标记独立的区域，区域样式变化时，浏览器会针对性的重新布局
    6. 禁止使用@import，此时如果从css文件没有下载，会等待下载，再继续渲染

# 浏览器

1. 从输入url到展示页面浏览器做了那些事情。
    1. 根据URL获取IP地址，可能是本地缓存，也可能是进行DNS查询
    2. TCP握手
    3. TLS协商（Transport Layer Security）
    4. 浏览器获取资源
        1. 如果本地存在缓存，判断缓存是否过期，如果没有过期，复用。如果过期发送Get请求获取资源。
        2. 如果本地不存在缓存，发送GET请求获取资源
    5. 如果资源是HTML。开始解析
        1. 解析之前进行一次预加载扫描
            1. 如果遇到rel=preload资源，请求获取资源
            2. 如果遇到CSS、JS文件，请求获取资源
        2. 解析HTML生成DOM
            1. 如果遇到CSS文件，请求资源
            2. 如果遇到script文件
                1. 如果是defer，请求资源，并在HTML解析之后执行脚本
                2. 如果是async，请求资源，待资源下载完毕立即执行脚本
                3. 如果都没有，阻塞HTML解析，一直到脚本下载完毕并且执行完毕
        3. 触发domcontentLoaded事件
    6. 解析完毕后开始构建CSSOM
        1. 如果有CSS文件没有下载完全会阻塞渲染
        2. 如果CSS文件中包含@import，阻塞渲染，下载文件
    7. DOM和CSSOM合并成render tree
        1. 布局：从Render Tree根节点开始，确定节点的大小和位置
        2. 绘制：将可见部分绘制到屏幕上
        3. 合成：将文档中不同层按正确的顺序合并到一起
    8. 触发load事件
    9. 页面展示。
    
2. 什么是跨域，同源策略。（https://www.bilibili.com/video/BV1Bk4y1W7ht/?spm_id_from=333.337.search-card.all.click&vd_source=fe81433332628c7f76960485cdf9a9e4）

    跨域：资源的域名、协议、端口不同

    同源策略：限制不同域资源之间的交互

    1. 跨域资源共享（CORS）：服务端响应头添加：Access-Control-Allow-Origin: *
    2. 代理转发：反向代理中配置目标域名（或资源路径）（服务器代理请求的资源）
    3. JSONP
        
        HTML src属性引用资源不会触发SOP（同源策略）

        ```js
        function jsonp(url, params, CB) {
          const script = document.createElement('script')
          script.src = `${url}?${stringify({ callback: "padding", ...params })}`
          window['padding'] = CB
          document.body.appendChild(script)
        }
        ```
        缺点：
        1. 只支持GET
        2. 需要后端配合，如果后端不可控，可能存在代码注入的风险
        3. 无法监听接口异常
    4. postmessage（H5）


3. preload与prefetch
    1. preload用于提前加载当前界面资源，浏览器在解析HTML的时候会识别此属性优先加载资源
    2. prefetch用于提前加载其他界面资源，会在loaded之后进行

4. 异步加载脚本async与defer
    https://html.spec.whatwg.org/images/asyncdefer.svg
    async在脚本下载完后，立即执行（可能会阻塞HTML解析）
    defer在异步下载脚本，并在HTML解析之后，DomContentLoaded之前执行

5. DomContentLoaded与load
    1. HTML解析完成后，DomContentLoaded事件触发
    2. 当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件

6. 浏览器使用ESM
    1. Module默认defer
    2. Module是单独作用域，不会污染到全局（IIFE）
    3. Module是strict
7. window
    1. requestIdleCallback：在浏览器空闲的时候执行函数（一般用于低优先级的任务）
    2. requestAnimationFrame：在浏览器下一次重绘之前调用指定函数更新动画
    3. postmessage：进程间通信
    4. queuemicrotask：微函数执行栈
    5. matchMedia
    6. getSelection
    7. MutationObserver：可以用来监视DOM Tree的变化
8.  iframe（微前端篇）
9.  图形绘制
    1. svg
        1. 矢量图形、可以添加事件处理器、可以使用css、结合Vue相对简单
        2. 性能差，不适合渲染大量动态图形（在单一图层，没有GPU参与）
    2. canvas
        1. 只能绘制栅格图形，不能绘制矢量图形、不支持事件处理器、缩放困难、动画需要手动实现
        2. 性能好（只考虑结果，不考虑过程）

# 计算机相关

1. TCP（看视频理解）
    1. 三次握手（https://www.bilibili.com/video/BV18h41187Ep/?spm_id_from=333.337.search-card.all.click&vd_source=fe81433332628c7f76960485cdf9a9e4）
        1. 客户端发送SYN
        2. 服务端接收SYN，响应SYN + 1、ACK + 1
        3. 客户端发送ACK + 1
    2. 四次挥手（https://www.bilibili.com/video/BV18h41187Ep/?spm_id_from=333.337.search-card.all.click&vd_source=fe81433332628c7f76960485cdf9a9e4）
        1. 客户端发送FIN + ACK
        2. 服务端接收FIN，响应ACK + 1
        3. 服务端发送FIN + 1、ACK + 1
        4. 客户端收到后发送ACK + 1
    3. keep-alive：客户端连接失效后，服务端不知道何时关闭连接，会自动发送报文检测客户端是否正常运行。
2. TCP和UDP的区别
    1. TCP基于连接，UDP基于非连接
    2. TCP可以保证数据顺序，UDP无法保证
    3. TCP面向字节流，UUDP面向数据报文
    4. TCP可以保证数据完整性。UDP可能会丢包
3. 鉴权
4. 安全（这里总结的不是很详细）
    1. XSS（Cross Site Scripting，跨站脚本攻击）（https://www.bilibili.com/video/BV1Qd4y1k7K4/?spm_id_from=333.337.search-card.all.click&vd_source=fe81433332628c7f76960485cdf9a9e4）

        向网站注入恶意脚本。
        
        攻击方式：伪造输入框、GET请求恶意参数

        预防：
        1. 输入校验
            1. 对输入格式进行校验，比如输入的账户是否是邮箱
            2. 对注入的内容过滤掉一些标签、事件属性
        2. 输出校验
            1. 对渲染的内容进行编码转义
            2. cookie设置为http-only，防止信息被窃取

    2. CSRF（Cross-site request forgery，跨站请求伪造）
        
        恶意伪造请求。

        预防：请求中添加CSRF-token，服务端接收请求验证token是否正确，如果不正确直接丢弃。前端cookie最好设置为http-only，防止攻击者拷贝cookie

    3. 点击劫持

        攻击者使用iframe将网站嵌入到自己的页面，然后伪造输入框覆盖原来的输入框，从而获取用户私密信息。

        解决：资源请求头添加X-FRAME-OPTIONS，禁止未经允许的界面使用iframe获取资源

    4. SQL注入

        服务端对用户的输入没有经过校验就插入数据库中。

    5. DDOS攻击：恶意发送大量请求SYN，导致服务器挂起多个资源并崩溃

        TCP连接，服务端不会保存SYN。

5.  http缓存（https://www.bilibili.com/video/BV17V411J78W/?spm_id_from=333.337.search-card.all.click&vd_source=fe81433332628c7f76960485cdf9a9e4）
    1. Expires：优先级等于cache-control，直接约定换缓存到期时间
    2. cache-control
        1. cache-control请求头包含属性：max-age、no-cache、no-store 
        2. no-cache与no-store区别
            1. no-cache可以在客户端缓存资源，但是每次都必须请求服务器检查新鲜度，来决定是从服务器获取最新资源（200）还是从客户端读取缓存（304），即协商缓存
            2. no-store不使用任何缓存
        3. public：可以缓存到中间节点和客户端
        4. private：只能在客户端缓存
    3. 强缓存：通过cache-control中max-age控制。不会向服务器发送请求
    4. 协商缓存：访问缓存前需要进行新鲜度校验（有些不清晰）
        1. 通过比对etag和if-none-match
        2. if-modifie-since和last-modified和对比
    5. ETAG：服务端如何校验客户端缓存是否有效
            
        如果是强缓存，第一次请求时服务端会返回ETAG，下一请求时客户端请求头会将ETAG的值塞入if-none-match中。
        如果是协商缓存，第一次请求时服务端会返回ETAG，下一请求时客户端请求头会将ETAG的值塞入if-modifie-since和last-modified中

    6. 更有效的缓存：可以按照路由拆分，对于改动不频繁的内容可以设置长期缓存


6.  http2：https://juejin.cn/post/6844903667569541133
    1. http/1.1缺点
        1. TCP连接数限制：对于同一个域名，浏览器只能创建几个TCP连接，所以一般是同一个域名创建几个子域名来增加TCP连接数
        2. 线头阻塞（Head Of Line Blocking）：每个TCP连接同时只能处理一个请求，如果当前请求响应阻塞，后续请求都会受阻。
        3. Header内容多且不会压缩，每次请求都需要携带
        4. 明文传输不安全
    2. http2优势
        1. 二进制分帧层（Binary Framing Layer）：报文消息被划分为更小的数据帧
        2. 多路复用：http/1.1中的帧可以在一次TCP连接中组合成流发送，而不需要创建多个TCP发送
        3. 服务端推送（server push）：客户端还没有请求，服务端就把一些必要的内容推送过去：http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html
        4. Header压缩（HPACK）
        5. 应用层的重置连接：可以在不断开连接的前提下取消stream
        6. stream请求优先级
        7. 流量控制
7.  https = http + tls
    1. http缺点：http内容使用明文传输，在传输过程中被劫持后传输内容完全暴露。不能判断数据是否被篡改。
        1. 数据明文传输
        2. 缺乏消息完整性检测
    2. https使用对称加密和非对称加密（CA数字签名 + 数字证书用于证明密钥的真伪）
    3. TLS协商
        1. 客户端发送请求并携带密码组合、随机数1
        2. 服务端响应密码组合和CA证书、随机数2
        3. 客户端发送随机数3，密钥生成
        4. 双方互发FIN
    4. 每次https请求都需要生成密钥吗
        1. 不会，服务器会为每个浏览器生成sessionId，在TLS握手阶段传给浏览器，之后浏览器的请求自动带上sessionId
8.  cookie访问范围
    1. 包含的属性domain、expire（max-age）、path、HTTPonly、secure、samesite
    2. localhost:3000 与 localhost:5000 的 cookie 信息是否共享：这个和domain、path字段有关，如果这俩个字段相同就共享
    3. secure设置后，不安全的站点无法修改cookie，且发送请求的时候不会将cookie发送给服务端
    4. httponly设置后，浏览器无法访问此类cookie，该cookie只用于服务器
    5. samesite
        1. strict：完全禁止跨站点请求携带cookie
        2. lax：链接（href）、预加载（preload）、GET表单可以携带cookie，其他不允许
        3. None
9.  get和post区别
    1. 浏览器回退，GET无影响，POST会再次请求
    2. GET产生的URL地址可以收藏、转发，POST不可以
    3. GET请求会被浏览器主动缓存，POST需要手动设置
    4. GET请求只能进行URL编码，POST支持多种编码方式
    5. GET请求参数随URL被记录到浏览器中，POST不可以
    6. GET请求参数有长度限制，POST没有
    7. GET请求参数直接暴露在URL上不安全，不适合放置敏感信息，POST是放在RequestBody中
10. http status code（https://zhuanlan.zhihu.com/p/603410395）

# js

1. V8垃圾回收机制
2. 作用域与闭包（文章）
3. this和对象原型（文章）
4. 类型与语法（文章）
5. amd、cjs、umd（文章）
6. 异步与性能
7. 洋葱模型：相较于axios请求、响应守卫拦截，它将请求和响应聚合到一起，使请求和响应关系更紧密。
8. 如何取消发送的请求
    1. XHR：XMLHttpRequest.abort()
    2. fetch: AbortController
    3. axios: cancelToken，0.22版本之后也可以使用fetch的AbortController
9. 事件循环（https://github.com/dwqs/blog/issues/61）（https://www.zhihu.com/question/268007969）
    1. web事件循环（chrome，async-await性能优化）
    2. node事件循环
10. 手撕代码
    1. Promise：https://zhuanlan.zhihu.com/p/183801144
    2. 算法
        1. 排序（https://mp.weixin.qq.com/s/a0LGAlPD2Rs60Cb4Uz0hwQ）

# nodejs

# vue（这里主要解释Vue3即可）

1. vue3优化
    1. 组合式API（Composition API）
    2. monorepo
    3. 响应式原理
    4. TS
    5. 体积减小：Tree-Shaking、删除不必要的API（一些实例属性$on$off$emit）
2. 响应式原理
    1. Proxy/Reflect
    2. watch/computed
    3. method与computed区别
    4. 如何代理Object、Array、Set、Map
        
        get、set、ownkeys、has、deleteProperty

3. 渲染器
    1. 虚拟DOM
    2. Diff算法：及时剪枝（tag、key）
        1. 简单Diff
        2. 双端Diff
        3. 快速Diff（https://www.bilibili.com/video/BV1JR4y1R7Ln/?spm_id_from=333.337.search-card.all.click&vd_source=fe81433332628c7f76960485cdf9a9e4）
4. 组件化
    1. 组件生命周期
    2. setup
    3. 内置插件原理
        1. keep-alive
        2. teleport
        3. suspense
        4. Transition
5. 编译器
6. 其他原理
    1. nextTick原理

        更新响应式状态时，vue不会立即更新DOM，而是将它们缓存到一个队列中，在下一次tick中执行。nextTick是等待DOM刷新的方法。

    2. provide/inject原理
    3. Vue插件
    4. Vue指令
    5. 组合式函数原理（`<script setup>`语法糖做了什么）
7. vue-loader原理：https://github.com/vuejs/vue-loader（没完全理解，后续继续）
    1. vue-loader使用@vue/compiler-sfc解析SFC，生成不同语言的导入
    2. 如果有js-loader，会添加到queries之前，如果有css-loader，会添加到queries之后
    3. 当有扩展请求发起时，vue-loader会将它传递给匹配的loader
    4. 使用Vue-template-compiler编译template；对于style scoped或module：
        1. 在css-loader之前，style-loader之后需要后续处理
8.  router原理
    1. hash只能改变#后面的值，history可以随意设置同源url
    2. hash只能添加字符串类数据，history可以通过API添加多种类型数据
    3. hash不需要服务端配置，history需要服务端配置
    4. hash通过location.hash跳转路由，通过hashchange event监听路由变化
    5. history通过history.pushState()跳转路由，通过popstate event 监听路由变化（但是无法监听history.pushState())
9. 性能优化
 
# TS

1. 相关API
2. TS原理与实现
    1. 枚举实现（js实现）
        ```js
        let enumObj
        (function (obj) {
          obj['apple'] = 'apple'
        })(enumObj || enumObj = {})
        ```

# 工程化

1. webpack（https://www.webpackjs.com/concepts/）
    1. 简单介绍webpack

        静态模块打包工具。可以进行模块打包、编译兼容、能力扩展。

    2. 构建流程
        
        初始化参数 -> 开始编译 -> 确定入口 -> 编译模块 -> 完成模块编译 -> 输出资源 -> 输出完成

        输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk加入输出列表

    3. webpack优化项目
        1. 开发环境优化
            1. 升级新版本
            2. 优化搜索文件
            3. 避免重复编译第三方库
            4. 开启多进程Loader转换
            5. 开启模块热更新（HMR）
        2. 生产环境优化
        
        3. terse、uglify、swc压缩js
        4. gzip、brotli传输压缩
        5. 分析打包体积，替换更小体积的库
        6.  使用支持Tree-shaking的库
        7.  对无法tree-shaking的库进行按需引入
        8.  合理使用browserlist，减少polyfill体积
        9.  coded-spliting，按路由加载包（优化性能）
        10. 使用 webpack 的 splitChunksPlugin，把运行时、被引用多次的库进行分包，在分包时要注意避免某一个库被多次引用多次打包。此时分为多个chunk，虽不能把总体积变小，但可提高加载性能 (PS: 此条不减小总体积，但可提升加载性能)

    4. webpack HMR原理
        
        <img src="https://pic1.zhimg.com/80/v2-f7139f8763b996ebfa28486e160f6378_720w.webp" />

        在不刷新页面的情况下更新内容。

        webpack-dev-server(WDS)监听代码变更，并与浏览器建立websocket连接，当代码变更时会将变更文件通知浏览器，浏览器通过JSONP获取更新内容替换。

        拿到增量更新内容后，由HotModulePlugin插件继续后续处理。比如vue-loader中使用了一些此插件的API来进行热刷新。

    5. plugin（https://juejin.cn/post/6844904094281236487?searchId=202309140902037E7B885A524345A065C2）
        
        1. 什么是plugin：用来解决loader无法解决的问题，比如性能优化和代码压缩。
        2. 原理（执行时机）
            
            插件类在实例化的时候会传入compiler，内置一些钩子，用来订阅构建的各个流程。

        3. 常用的插件
            1. html-webpack-pluign：处理html资源，默认会创建一个空的 HTML，自动引入打包输出的所有资源（js/css）
            2. mini-css-extract-plugin：打包过后的 css 在 js 文件里，该插件可以把 css 单独抽出来
            3. clean-webpack-plugin：每次打包时候，CleanWebpackPlugin 插件就会自动把上一次打的包删除

    6. 性能优化（https://zhuanlan.zhihu.com/p/139498741）

        1. 分析工具：webpack-bundle-analyzer
        2. 构建速度优化
            1. 代码压缩：使用terser-webpack-plugin压缩JS代码，使用css-minimizer压缩css代码，使用htmlwebpackplugin压缩html
            2. 资源压缩：配置image-loader压缩图片
            3. tree-shaking

                依赖于ESM静态语法分析，用于消除死代码。`usedExports`在未使用的函数标注，在terser中优化。`sideEffexts`跳过模块/文件（package.json中设置）

            4. 缩小打包范围：使用include和exclude
            5. 对于多页面应用，提取公共代码
            6. 使用缓存。cache-loader
            7. 使用DDL，避免静态文件重复打包
            
    7. source map
    8. 文件指纹

        打包后文件名

        [ProjectHash]-[ChunkHash]-[contentHash].js

        ProjectHash：项目发生改变时，整个项目hash都会变更。
        chunkhash：和chunk有关，不同entry的chunkhash值不同
        contenthash：根据文件内容定义hash

2. vite
    1. rollup及vite简介
    2. 插件原理
3. tree-shaking原理
    1. 基于ESM进行静态分析，通过AST将未引用的代码移除，减少打包体积
    2. webpack会先标记未使用的代码，然后再UglifyJSPlugin中删除代码
4. npm包
    1. 本地如何发包
5. 仓库管理
    1. monorepo：workspace
        1. pnpm + changeset
6. docker
7. git
    1. git rebase和git merge区别：merge就是正常的合并，git分支是交叉的。rebase会以一个分支为基础，将另一个分支在交叉提交之后的所有提交连接到当前分支上，之后分支不存在交叉。
    2. hook：git在执行的时候会抛出一些同步钩子
8. vite、webpack是如何实现css-module的（为什么可以通过ESM导入的方式导入CSS文件）
9.  ts-loader做了哪些事情
10. vite和webpack比较
    
    webpack是一个构建工具，对标rollup，vite是在rollup基础上构建的工具。相当于添加了一些loader、plugin的rollup工具。

11. CSS Scoped | CSS Module

            scoped内的CSS只作用于当前组件中的元素，但是子组件根元素会受到父组件影响（一般用于布局）。scoped组件如果想深层次影响子元素样式，需要::v-deep()。

            - css specificity，scoped样式是类 + 属性选择器的一种，它的权重优先级高于类选择器，但是性能低于类选择器和ID选择器。
            - 因为使用的类选择器字符是固定的，所有有可能被祖先节点同名类样式影响。
            - 递归组件应该避免使用scoped，尤其是scoped内部包含后代选择器，性能损耗极大。可以将样式抽出，进而避免内存损耗

            vue-style-loader css-loader modules: true打开，然后可以替代scoped方案：

            1. module可以像JS对象一样使用，甚至可以传递给子组件
            2. 最后生成的是类选择器，类名随机，与scoped的类属性选择器不同

# electron
1. v8
2. browserWindow
3. protocol
4. IPC
5. container

# 设计模式

## 分类（https://baijiahao.baidu.com/s?id=1661505290125455712&wfr=spider&for=pc）

1. 行为型模式：一般用于在不同实体之间进行通信
    1. 访问者模式
    2. 观察者模式：当状态发生改变时，会通知订阅此变化的对（一般通过回调的方式）
    3. 策略模式：类中控制一系列行为，比如打折，5折、9折对应不同的操作
    4. 迭代器模式：提供方法，按照一定的顺序方位对象内元素
    5. 解释器模式
    6. 状态模式：类内部状态改变，类的行为也会改变
    7. 责任链模式：对象链式调用内容
2. 创建型模式：提供实例化的方法
    1. 单例模式：提供一个只能实例化一次的类，之后的实例化只能返回第一次实例化的对象
    2. 工厂模式：提供一个抽象化类，用来创建特定类型的对象
    3. 原型模式：新的对象只能通过拷贝原型对象进行创建
    4. 创建者模式：将负责对象的构建与它的表现分离，比如创建车，既可以是创建汽车也可以是创建货车
3. 结构型模式：一般用来处理实体之间的关系
    1. 适配器模式：通过中间类调用另一个接口，类似代理模式
    2. 组合模式：
    3. 代理模式：不直接修改对象，而是通过中间对象代理实现
    4. 装饰模式：动态的给对象添加额外的能力（实际执行可能不仅仅是当前方法）

## 原则

1. 单一原则：一个类只负责一项职责
2. 里氏替换原则：子类只能替换父类，但是不能修改父类方法
3. 依赖倒置原则：依赖于抽象而不依赖于具体
4. 接口隔离：接口的封装应该最小化，避免代码耦合
5. 迪米特原则：精简类中方法
6. 开闭原则：对扩展放开，对修改关闭

# nest + typeorm
# python + django

## 接口性能优化（https://zhuanlan.zhihu.com/p/584477523）

# 项目问题

1. 定制化业务线与Arch

    背景：需求激增，但多数是在原有功能上进行改进，扩展。为了避免新增代码影响源代码，且支持后续快速化定制，所以独立出此业务线。

    Arch技术栈沿用MDesign4，并以4.1版本为基线。但是在建设过程中，发现它的功能复用程度很大，与定制化业务契合，所以俩个业务线合并。

    难点：对于客户端开发，存在很多配置文件并且独立在不同模块中，定制化业务就是需要把这些配置从原有的业务中抽离出去，统一放置到Node层中，配合环境变量，实现定制化。但是配置文件的抽离会破坏模块化设计且不利于项目合并，所以使用运行时请求并替换配置文件。

    三方集成：和其他公司合作的项目，独立为插件，然后参与定制化

2. 甘特图

    技术调研阶段：调研了一些开源框架和市面上流行的产品比如飞书，发现了一些问题：

    1. 难以和我们的业务相结合
    2. 使用了canvas，虽然在性能上表现好，但是项目中没有canvas基础，从0开发需要引入大量插件，比如事件监听，滚动监听等，而且canvas没有template层级结构，不利于后续维护。

    方案选用：将甘特图分为俩部分，表格和图表，甘特图表格部分使用了el+，图表部分使用DOM渲染时间条，结合dayjs完成时间线。时间条使用相对定位 + margin进行偏移。通过监听表格部分滚动条，实现懒渲染。

    细节上的考虑：
    3. 为了保持数据一致性，任何修改都会全量更新数据

3. Md4项目介绍
    
    主要是解决项目操作不支持前进后退、性能差、建模内容无法自定义的问题。项目初始化时，部分技术选型被划分为开发任务交由各开发人员完成，其中我引入了引入CSS Module；引入SCSS；引入Jest；引入Husky等技术。也参与了一些基础内容的建设。包括状态管理设计，插件系统设计，术语库设计，独立进程窗口设计。

4. 自研图形引擎Design Graph
    
    历史问题：Mdesign3使用MXGraph，图形扩展难度大、性能低、框架体积大、与业务绑定太深导致跨平台难度大
    
    Design Graph是独立组件，支持跨平台。Vue3响应式和svg结合绘制图形，向外导出graph类，抛出一些操作钩子，实现图形统一控制。

    缺点：
        1. svg在性能上表现较差，（canvas）
        2. 业务分离不明显，很多逻辑需要在多平台复写（monorepo）
    
    为什么不使用canvas：
        3. 不支持DOM事件绑定。
        4. 没有类似组件template的结构，使其维护起来不便，不利于抽象通用行为。

5. 状态管理设计
    
    项目初始化时，我负责各类菜单功能开发，和很多开发人员功能重复。为了解决上述问题，将各类功能抽象为类——Action，Action维护对应的状态，方法等。后续对VueX、Pinia进行调研，发现和Pinia的组合式语法相似，比如可以借助类的扩展实现通用方法，加强类型提示等。

6. 插件系统设计

    首先是协商定义插件接口规范：启动、终止、重启、日志

    UI层根据启动命令和启动端口调用Electron执行shell，并提供进程容器包裹插件UI。为了防止插件不合理调用接口，插件只能通过单个接口使用不同参数请求主进程资源，插件系统使用Electron.protocol拦截请求再通过IPC发送至主进程，就可以不是单纯的调用接口，这样不会影响前端状态与数据的不一致。

    其他问题：与vue、webpack、vite插件不同，我们的软件没有提供同步的Hooks，是因为我们插件插入时机不同，我们是在软件运行中使用插件，不能保证hooks动态注入。再者插件不能完全融入主进程，因为一定是单独进程，或者可执行程序。

7. 术语库设计（先了解i18n插件）
    
    第一版使用i18n，但是只能用在单个项目内。不同项目组产品会重复做功，而且不能保证文案统一。第二版将其抽离为组件，统一各个项目产品文案、包括各类专业术语、文案话术、时间日期数字格式。暴露出覆盖API，用于不同项目中特殊文案。产品人员维护一个Excel，由脚本转换为JSON，

    缺点：
    后端返回的内容由语句变为术语，不利于开发。

8. 独立进程窗口设计**（等待electron完善）**
    
    Vue-router + BrowserWindow实现独立进程窗口，为了保持app.eventbus传递消息，所有独立进程窗口必须在主进程下启动。但是独立窗口第一次启动很慢，所以在项目启动的时候会预加载独立窗口，以优化启动速度。通过URL传递参数。

9.  技术引用（这里感觉不够详细，还需要进一步补充）
    
    JEST（https://github.yanhaixiang.com/jest-tutorial/basic/test-environment/#jsdom-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83）
    
    场景：快速迭代的时候，我负责软件中各个菜单功能，与其他开发人员交互频繁，导致我开发的一些功能在不知情的情况下被修改，所以引入JEST和HUSKY，代码push前会运行单测。

    解决了哪些问题：单元测试可以保证代码质量，避免已通过测试的功能被破坏。

    后续存在的问题：

    1. 开发流程不规范是主因，在此前提下追求测试覆盖率反而延长开发时间，尤其是对频繁改动的功能。
        1. 产品与功能不同步
    2. 业务混乱是次因
    3. 项目业务分离不明显，导致单测输入输出不可预知。同样不能测试驱动开发（TDD）
    4. 业务复杂，单测难度不亚于开发
    5. mock只能模拟数据，不能模拟业务

    快照测试：先打印HTML结构保存起来，下次运行单测时同新的HTML对比

    静态Module处理：JEST不会和webpack产生交互

10. 简单说下node层

    软件分为四层，前端有UI层、Node层，层与层之间只能相互通信，不能跨层通信。Node层是中间层，主要用来处理图形交互、存储数据、处理项目文件。Node的加入主要是为了解决项目操作前进和后退的问题，其中一个概念叫step，意为执行步骤。具体实现为，前端每次请求都会进入事务，如果一次事务中存在修改数据的操作，会将其插入step表中用于前进后退，每行step数据中有一个change字段，用于记录新增、删除和更新操作的内容。如果是一次操作多个事务，会通过stepId更新change字段。

    删除通过修改isDelete字段实现

    更新相当于拷贝原来数据、然后删除、然后新增。

    分段处理数据，需要保存事务状态。然后修改事务中数据的变更。

    其实对前端来说，这一层很多余。前后端是链式请求的，node层积累大量中间接口。因为业务的特殊性，Node层和后端是单线程的。再者很多开发人员没有接触过后端，开发不是很规范。整个Node层代码很混乱。且前端没有对node进行分层，而是前后端都写。大部分人对ui层更熟悉，node代码很混乱。因为是核心工具，其他项目组成员有时也会来上手代码进行对应项目交接。

11. 追溯图
    
    算法应用。层序遍历。

12. 系统菜单组件**（等待electron完善）**
    
    右键菜单组件：使用栈的方式实现子菜单的展开和隐藏

13. 快捷交互相关

    快捷键、功能键：局部快捷键相关

    全局拖拽：

    全局缩放：chrome中zoom、origin属性问题

14. 窗口自定义布局（待补充）

    最开始使用的是vue-grid-template组件，交互效果不符合产品预期。最后将界面中主要窗口改为grid布局，使用

15. 性能优化

    1. 接口优化
        1. 统一接口范式：所有请求改为复数
        2. Node层合并处理结果

            如果不声明立即返回数据，默认合并处理结果：时间过期、遇到错误、遇到立即返回结果的接口，会将缓存内容推送出去再清空。

        3. 缓存请求结果
        4. 长接口自动loading。
    2. Node层数据处理优化
        1. 切割处理数据：如果标注是无关联的数据，会切割数据分开处理
        2. 数据库层级数据请求优化：单次请求会根据文件id获取所有元素，然后拼装成树

            缺点：只适合无关联性，且数据量小，跟业务绑定紧密

        3. 优化代码逻辑：递归转为迭代，层级迭代降低层级，深度遍历及时剪枝。

    3. 渲染优化
        
        降低坐标精度：坐标使用整数方便数据I/O，且能提升SVG渲染速度

        移除组件内css style，改为内联样式和全局样式。
        
        减少插槽的使用。

        项目打开时优先提供Graph图形数据。

        SVG中使用path绘制内容：使用rect这样需要创建多个对象，path可以一笔带过

16. Design Graph跨平台

    因为Graph主要由MD项目组维护，且版本号更改频繁。其他项目组使用时交接困难。不适合通过组件的方式引用graph。其他项目组没有模型解析服务，需要单独维护一个服务用于graph数据解析。

    所以采用iframe加载graph

17. Mdesign4项目打包问题
    1. 为什么选择webpack + electron
    2. 如何打包成`.exe`程序
    3. 打包后路径问题
    4. Node、Java如何进行交互

# 自我介绍

面试官你好，我叫刘振，毕业于浙江农林大学，本科专业地理信息科学。目前工作俩年，毕业后一直就职于杭州华望系统科技，离职前负责和开发定制化业务线前端。

个人主要技术栈Vue3，上一份工作中接触过Electron和Nestjs。业余时间学习过Python Django，并使用其建设个人网站。平时会刷算法题，目前leetcode有500题。

我的简历有些凌乱，其中列举了项目开发主要遇到的一些困难，为了保持简历页数所以没有详细介绍难点背景和解决方案，你可以提问你感兴趣的功能点或者项目。

# 有什么想问面试官的

1. 产品研发的流程
2. 现有项目开发中，前端有架构师介入吗？架构师应该在项目中扮演什么样的角色。
3. 开发团队中有技术分享吗？
4. 对我今后学习方向有什么建议？

# 离职原因

1. 出差频繁；驻场开发；
2. 行业限制，导致产品人员变动大。使得开发需要负责更多的事务。
3. 技术没有突破，会使个人产生技术惰性，缺乏学习动力，所以坚持离开工作。
4. 其实个人是在22年12月就已经提出离职，但是正好赶上新业务线，所以临时受命没有走。今年5月份版本发布之后才走的，

> ### 面试中如果遇到问题，回来后及时做总结，然后得出详细思路
