# 类型与语法（数据类型 + 类型判断 + 类型转换）
# 数据类型 & 类型判断
<!-- 首先是简述，介绍这篇文章涉及js的范围，深度。范围还要介绍与其他知识点的关联，深度上至二次开发，下至浏览器原理（基于浏览器实现的DS或中间数据结构 -->
本篇文章建立在读者熟知熟用js数据类型基础

## 数据类型
### Array
<!-- 我觉得`empty`这种除了在输出方面存在差异，其余与undefined没什么不同 -->
使用`new Array(number)`会创建`[empty * number]`的数组（以下称**存在空白的数组**），这种数组不同于`[undefined * number]`，它们行为存在一致，但是实际上是不同的东西，对此可做以下处理：
1. 如果数组容量小，可以直接使用字面量声明的方式
2. 声明空白数组时及时填充初始值，并在之后开发禁用`delete array[index]`方式避免`empty`的出现
3. 使用`Array.apply(null, { length: number })`的方式声明数组
4. ES6使用`Array.from({ length: number })`，效果同3

上述存在的差异`Array.join`可以体现出来：
```js
Array.prototype.join = function (connector) {
  let str = ''
  for (let i = 0; i < this.length; ++i) {
    if (i > 0) str += connector
    if (this[i] !== undefined) str += arr[i]
  }
  return str
}
```
### String
对于**原地修改**变量的方法，比如Array.prototype.splice，无法应用到字符串上

### typeof原理
typeof返回值为`[Object xxx]`，其中`xxx`代表对象的内部属性`[[Class]]`，这个内部属性无法直接访问，可以通过`Object.prototype.toString()`查看。

### Symbol
## 抽象值操作（ToPrimitive）
### ToString（这是抽象操作，不是`String#toString()`）
对于对象，首先检查是否存在`valueOf`方法，如果有并返回基本类型值，则使用该值进行强制类型转换；如果没有使用`toString`的返回值进行强制类型转换。如果`valueOf`和`toString`均不返回基本类型值，会产生`TypeError`错误。

`toString`是**强制类型转换**，`JSON.stringify`有许多与其相同的表现：
1. `JSON.stringify`在对象中遇到`undefined`、`function`和`Symbol`会自动忽略，在数组中则返回`null`以单元位置不变；
2. 对象中自定义`toJSON`方法，在被序列化时会自动调用该方法。`toJSON`返回的是一个能被字符串化的JSON值，而不单单是一个字符串：
    ```js
    const a = { b: 10, toJSON: function () { return { b: 10 } } };
    JSON.stringify(a); // '{"b":10}'
    ```

### ToNumber

### ToBoolean
`falsy`的反面即是`truthy`，又一个地方会存在误解，即包含`falsy`的对象，这一点区别于空对象`{}`：
```js
  const a = new Boolean(false);
  const b = new Number(0);
  const c = new String('');
  const d = Boolean(a && b && c); // true
```

## 显示类型强制转换
### 字符串和数字之间的显示转换
1. `+ new Date()`：返回时间戳；ES5之后不建议这种写法，可以使用`Date.now()`，其polyfill：
    ```js
    if (!Date.now) {
    Date.now = function () { return +new Date() }
    }
    ```
2. `~String.prototype.indexOf()`：配合`if`可以强转为`Boolean`，避免出现`>= 0`或`!== -1`这种碍眼的代码，使代码更优雅，比如：
    > 原文中对`~`这类位操作符还有很多描述，但是这类描述过于琐碎，这里没有类举

    ```js
    const str = 'abcdef';
    if (~str.indexOf('c')) { ... }
    ```
3. `~~`：去除小数位；它不是向下取整，不同于`Math.floor`：
    ```js
    Math.floor(-1.6); // -2
    ~~-1.6; // -1
    ```
    而且同很多位运算符一样，只适用于32位数字，对于`~~x`，表现和`x | 0`一致

### 显示解析数字字符串
```js
parseInt(1/0, 19) // 18
```
`parseInt`会对第一个参数进行`toString`强转，`1/0`被转换为`'Infinity'`，然后从左到右解析`'Infinity'`得到`i`，在19进制中代表18.
> 但是`parseInt`存在一个bug，就是以`0x`开头的字符串会被默认解析为8进制，所以在解析时尽量传入第二个参数既定进制

### 显示转换为布尔值
状态转换语句中（三元、`if`、`while`等），应该显示强制类型转换，是代码更明确（优先使用`!!`）

## 隐式强制类型转换
### 字符串和数字之间的隐式强制类型转换
1. 如果`+`的其中一个操作数是字符串（或者可以通过`ToPrimitive`转换为字符串），执行**字符串拼接**；否则执行数字加法。
2. 根据`ToPrimitive`抽象操作规则：`String`直接调用`toString`；`str + ''`参考line 47
    ```js
    const a = { toString: function () { return 4 } }
    a + '' // "4"
    String(a) // "4"
    a.valueOf = function () { return 42 }
    a + '' // "42"
    String(a) // "4"
    ```
3. 操作符`-`俩端只能是数字：
    ```js
    const a = [3]
    const b = [1]
    a - b // 2
    ```
    首先`a`和`b`通过`toString`转换为字符串，然后字符串通过`ToNumber`再转换为`Number`

### `||`和`&&`
`||`和`&&`首先对第一个操作数执行**条件判断**，如果不是`Boolean`，执行`ToBoolean`，然后再执行条件判断。对于`||`，如果判断结果为`true`就返回第一个操作数的值，否则返回第二个操作数的值；对于`&&`，如果判断结果为true，则返回第二个操作数的值，否则返回第一个操作数的值。

## 宽松相等和严格相等
**`==`允许相等比较中进行强制类型转换，而`===`不允许**。当俩端类型相同时，宽松相等等同于严格相等。当俩端类型不同时，有以下几种情况：
1. `Boolean`和非布尔类型（优先级最高）：对`Boolean`执行`ToNumber`
    ```js
    const a = '42'
    const b = true
    a == b // false
    ```
    上面`true`先触发`ToNumber`变成`1`，也就是`'42' == 1`，然后`'42'`触发`ToNumber`变成`42`，最后对比为`42 == 1`，结果为`false`。整个过程没有涉及`ToBoolean`，也就是相等与俩端是`truthy`还是`falsy`没有关系。
2. 对象和非对象：对对象执行`ToPrimitive`，以下三种情况需要注意：
    1. 基础数据类型的拆箱（boxed）和装箱(unboxed)，主要是使用对应的封装对象，效果同`Object(Primitive)`
    2. `null`和`undefined`没有对应的封装对象，所以`Object(null)`和`Object(undefined)`返回的是常规对象
        ```js
        const a = null
        const b = Object(a) // {}
        a == b // false
        const c = undefined
        const d = Object(d) // {}
        c == d // false
        ```
    3. 因为`NaN != NaN`，所以：
        ```js
        const a = NaN
        const b = Object(a) // NaN，等同于`Number(NaN)`
        a == b // false
        ```
3. `String`和`Number`：对`String`执行`ToNumber`
4. `null`和`undefined`
    ```js
    null == undefined // true
    ```
5. 








js中有俩类数据类型：
- [Primitive values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#primitive_values)：MDN的中文翻译是“原始值”，
- [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#object)

## 基本数据类型
### Null
  
  Null数据类型只有一个值：null，通常被用来表示没有**对象**（MDN是这么说，当然本人也倾向于这种解释，方便与undefined区分）：
  ```js
    typeof null; // 'object'
  ```
  
  js中null的应用少得可怜：
  - [原型链末端](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)，这个非常重要。从这一处我们也可以看出，为什么null被当作对象来看待
  - Object的一些静态方法，比如`Object.create()`，可以将null作为参数传进去；再比如`Object.getPrototypeOf`：
    ```js
      const a = Object.create(null);
      Object.getPrototypeOf(a); // null
    ```

  类型判断很直接：
  ```js
    function isNull(x) {
      return x === null;
    }
  ```

  null做为[关键字](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar)存在，直接被JE识别，不能做任何赋值操作。介绍null这一特点其实无关紧要，因为开发过程中是和undefined同等看待的。

### undefined

  undefined类型也只有一个值：undefined，一个全局属性，通常被用来表示没有值，会在以下场景中被默认返回：
  - `return;`语句会隐式返回undefined，如果你想让你的函数更语义化，可以根据返回值的类型确定是`return undefined;`还是`return null;`
  - 访问不存在的对象属性
  - 变量声明时没有初始化会被默认初始化为undefined（这也是变量提升问题中，初始化前变量值为undefined的原因）
  - 标准内置对象的一些方法，比如Array.prototype.find(), Map.prototype.get()，当没有发现元素时返回undefined
  - [void运算符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void)
  
  类型判断也很直接：
  ```js
    function isUndefined(x) {
      return x === undefined;
    }
  ```

  与null不同，undefined是一个普通的标识符，也就是你可以对它这么干：
  ```js
    undefined = 1; // 1
  ```
  不过没什么意义，因为在全局作用域下不能改变undefined，非全局作用域下可以修改，但不建议在项目中修改它：
  ```js
    // !global block
    var undefined = 2;
    console.log(undefined); // 2
  ```
  这就是null中我们说的有趣的现象（似乎又不是很有趣），平时开发的时候对他们混用，但实际上存在一些不同，再比如：
  ```js
    Number.isNaN(1 + null); // false
    Number.isNaN(1 + undefined); // true
    null === undefined; // false
  ```
  这里可以看出`null`和`undefined`的不同
  <!-- 引申：浏览器是如何识别标识符和关键字、保留字的 -->

### Boolean

布尔类型包含俩个值：`true`和`false`，多用于条件运算。开发中我们最常应用的是`truthy`和`falsey`，但是这里我不打算介绍他们，因为在js中
<!-- 介绍js是如何执行条件语句进行状态转换的！！！！！ -->

### Number

  - [Number.EPSILON](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON)：该属性表示一个数字最邻近浮点数与它的差
    > 常见面试题《0.1 + 0.2 !== 0.3》中会应用到这个属性。在二进制中也存在无限小数（类比十进制中1/3），但是IEEE精度是有限的，导致遇到这类数字时不得不丢失精度。比如0.3对应的二进制是0.01001100110011...：
    ```js
      equal = Math.abs(a + b - c) < Number.EPSILON
    ```
    可以理解为在约定的误差下认为它们是相等的

### BigInt
  - 与Number相互运算，会抛出TypeError
  - 不符合IEEE 754
  - 与Number之间的转换会存在精度丢失，浮点数也有精度丢失的情况

### Symbol
  - 不能使用其他操作符
  - 一般被用来创建匿名且不可枚举的属性
    ```js
      const myPrivateMethod = Symbol();
      this[myPrivateMethod] = function() {...};
    ```
    - 因为不可枚举，无法作为for...in...的成员出现
    - 因为匿名，不能被Object.getOwnPropertyNames()访问，但可以被Object.getOwnPropertySymbols()访问
  - symbol注册表的内容不会出现在js运行环境，只有通过中间方法获取（Symbol.for，Symbol.keyFor()）

## 基本数据类型通用特性
- 基本数据类型的值是[不可变](https://developer.mozilla.org/zh-CN/docs/Glossary/Immutable)的，即任何操作不会改变原始值本身，而是返回对原始值的操作结果
- 拆箱与装箱
  - 基本数据类型是没有属性的，但是在js中，基本数据类型构建后有一些默认的方法属性，且给基本属性加上属性不会抛出TypeError错误
  - 显示拆箱
    - toString()，valueOf()这种
  - 显示装箱
    - 通过构造函数声明基本数据类型
    - 基本数据类型的属性都是装箱（通过构造函数的隐式装箱）时添加的

## 引用数据类型
- 对象属性
  - 数据属性
    - [[Value]] = undefined
    - [[Writable]] = false
    - [[Enumerable]] = false
    - [[Configurable]] = false
  - 访问器属性
    - [[Get]] = undefined
    - [[Set]] = undefined
    - [[Enumerable]] = false
    - [[Configurable]] = false

## 基本数据类型和引用数据类型的区别
- 存储区别
  - 引用数据类型引用的数据存储在堆中，但是指针（声明的引用变量）和基础数据类型一样，都是存在栈中

## Q&A
1. 既然基本数据类型存在装箱和拆箱，那是不是和引用类型没有什么区别，为什么会被保存到不同的位置呢

## 顶层引用
1. https://developer.mozilla.org/
2. https://github.com/getify/You-Dont-Know-JS/tree/1st-ed
3. https://www.ecma-international.org/publications-and-standards/standards/ecma-262/