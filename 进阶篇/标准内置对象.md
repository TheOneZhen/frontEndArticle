标准内置对象
	基本对象
		Object
			构造函数
				js中构造函数会默认返回this（当前所指对象），也可以主动返回一个对象替代this
			静态方法
				getOwnPropertyNames
					获取对象可枚举和不可枚举的属性，返回属性对应的string[]
				freeze
					冻结一个对象的属性（不能添加、删除、修改、可枚举性、可配置性、以及原型）
					对于引用属性，只能冻结地址，不能深度冻结
				defineProperty(obj, prop： string, descriptor: {})
					obj：要定义属性的对象
					prop：要定义或修改的属性名称或Symbol
					descriptor：属性描述符
						prop.value?: K = undefined
						prop.enumerable?: boolean = true
							设置对象属性是否可枚举，即是否可被for-in（还会获取原型链的自定义属性）和Object.keys()捕捉
						prop.configurable?: boolean = false
							设置对象属性是否可被删除以及其它特性是否可被修改
						prop.writable?: boolean = false
						get?: (function () => K) | undefined
							访问该属性时触发的方法，返回值做为prop.value的值
						set?: (function () => void) | undefined
							设置该属性时触发的方法，没有返回值
				getOwnPropertyDescriptor
					返回指定对象的自有属性的属性描述符（不会查找原型链）
				getPrototypeOf
					返回指定对象的原型
				isExtensible
					判断一个对象是否可扩展（是否可以添加新的属性）
						Object.seal、Object.freeze、preventExtensions会阻止属性的添加
				setPrototypeOf
					给对象设置原型（对象实例化之后）
						性能很差，因为会全局检索
							对象在实例化/创建的时候就应该设置好[[prototype]]
					在不兼容平台的实现
						if (!Object.setPrototypeOf) {
  // 仅适用于Chrome和FireFox，在IE中不工作
  Object.prototype.setPrototypeOf = function(obj, proto) {
    if (obj.__proto__) {
      obj.__proto__ = proto;
      return obj;
    } else {
      let fn = function() {
        for (let key in obj) Object.defineProperty(this, key, {value: obj[key]});
      };
      fn.prototype = proto;
      return new fn();
    }
  }
}
			实例属性
				Object.prototype.constructor
					一个引用值，指向Object构造函数
				Object.prototype.__proto__
					指向一个对象，当object实例化时，使用该对象作为实例化对象的原型
			实例方法
				Object.prototype.hasOwnProperty
	Map与WeakMap区别
		Map是强引用类型，WeakMap是弱引用类型
			例如对于全局定义的Map和WeakMap，在非全局作用域A中，二者使用A中定义的引用型变量做为key，那么在A销毁后，WeakMap会销毁此key，而Map不会
				const map = new Map()
const weakMap = new WeakMap()
(function() => {
  const A = {a: 1}
  const B = {b: 2}
  map.set(A, 1)
  weakMap.set(B, 2)
})()
					立即函数执行后，weakMap为空
			弱引用不会影响垃圾回收器回收
	反射
		Reflect
			静态方法
				Reflect.construct(target, argumentsList[, newTarget])
					与其它方法的异同
						对于Object.create()都是通过明确指定构造函数和原型对象来创建一个新的对象
						使用Object.create()和Function.prototype.apply()如果不使用new操作符调用构造函数，构造函数内部的new.target值会指向undefined。调用Reflect.construct()来创建对象，new.target值会自动指定到target
				delete(target, propertyKey)
					删除对象的属性值
		Proxy
			Proxy基于JE会拦截对象的默认行为（不仅仅是简单的包装器）
			递归代理
				var target = {
  a:1,
  b:{
  	c:2,
    d:{e:3}
  }
}
var handler = {
  get:function(trapTarget,prop,receiver){
    var val = Reflect.get(trapTarget,prop)
    console.log('get',prop)
    if(val !== null && typeof val==='object'){
    	return new Proxy(val,handler) // 代理内层
    }
    return Reflect.get(trapTarget,prop)
  },
  set:function(trapTarget,key,value,receiver){
    console.log('触发set:',key,value)
    return Reflect.set(trapTarget,key,value,receiver)
  }
}
var proxy = new Proxy(target,handler)
proxy.b.d.e
// 输出： 均被代理
// get b
// get d
// get e 
					proxy对属性链会递归调用陷阱函数（不确定）
					递归代理只需要在调用时代理即可