# 异步与性能

## 异步
JS是单线程语言，随着计算机技术的不断发展，单线程无法满足应用所需。在ES5之前，ECMA规范并没有细致**JS运行时（JS Runtime）**，ES6在原有基础上做出了本质性改变。其中最重要的概念就是：**事件循环（Event Loop）**。一般地，JS宿主环境（比如Web Worker）会依据[ECMA-Agents](https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#sec-agents)为**JS运行时**提供如下资源：
- 主线程(Main Thread)：执行JS代码
- 额外线程(Additional Threads)：和宿主环境强相关，比如Web Worker下的定时器、网络线程、渲染线程、解释器线程等
- 执行上下文集合([Execution Contexts](https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#sec-execution-contexts))：类似作用域(Scope)实例，记录变量声明
- 执行上下文栈(Execution Context Stack, or Call Stack)：函数调用栈
- 任务队列(Task Queue, [ECMA-Job](https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#job))：任务队列，比如定时器任务、事件任务等
- 微任务队列(Microtask Queue, [ECMA-Promise Jobs](https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise-jobs))：异步任务队列
然后宿主环境下的JS引擎(JE)通过**事件循环规则**调度这些资源的：
- 如果任务队列为空，等待任务
- 如果任务队列不为空
    - 执行第一个进入任务队列的任务
        - 如果遇到同步函数，入**执行上下文栈**并执行该函数
            - 如果遇到同步函数，push到执行上下文栈并执行该函数，循环往复
            - 函数执行完毕，出**执行上下文栈**
        - 如果遇到Promise函数，塞入微任务队列
        - 如果遇到事件函数，塞入任务队列
    - 清空任务上下文

> 上述只是简单介绍任务循环，不同宿主环境对规范有不同的细致

## 回调
ES5之前通过回调函数实现异步，会出现以下问题：
代码层级深，难以维护，即回调地狱问题

## Promise
### Promise.resolve()
1. 如果instance是非Promise，返回Promise(instance)
2. 如果instance是Promise，返回instance
3. 如果instance是thenable，返回Promise(instance)，且Promise.then === Promise.resolve(instance.then)，即链式封装

### Promise.all()
> `Promise.all([])`会立即完成

### Promise.race()
> `Promise.race([])`会导致Promise永远不会被决议（宿主环境可能输出`Promise<pending>`，会一直挂起），开发时一定要避免这种情况发生！

### Promise.prototype.finally ( onFinally )（ES7）
onFinally没有任何参数

### Promise的局限性
1. 错误捕捉
2. 无法取消，只能丢弃

## 生成器(generator, ES6)
```js
function *gen() {
  let i = 0, max = 10;
  while (i < max) {
    // yield优先级太低，进行运算时必须加上括号
    const input = 2 * (yield i++)
    if (input) max = input
  }
  return max
}
// 执行生成器函数，得到一个迭代器
const it = gen()
// 第一次执行.next()是启动it
it.next() // { value: 0, done: false }
```
每次调用迭代器的`next()`，都会让迭代器停在`yield`或`return`，生成器的状态（作用域）会被保持。如果是停在yield，下一次`next`可以传入单个参数，并由程序内部接收，就好像为上一次`yield`擦屁股一样：
```js
// 上一次next中传递的是参数默认值`undefined`，所以没有执行`if(input) max = input`
it.next(20) // { value: 1, done: false }
// 这一次传入20，yield计算后并赋值给input
```
但是启动生成器时（第一次执行`next()`）没有必要传入参数，因为它不需要为谁擦屁股。

挡迭代器停在`return`时，代表迭代器执行结束，函数返回值作为迭代器的value，迭代器结束：
```js
// 假设结束
it.next() // { value: 40, done: true }
```
还可以手动结束生成器（传入的值作为迭代器的value）：
```js
it.return('end of gen!') // { value: 'end of gen!', done: true }
// 或者
it.throw('error!') // Uncaught error
```

### 迭代器（iterator）
ES6之后，Array类型有一个特殊的计算属性：`[Symbol.iterator]`，调用这个属性会返回一个新的迭代器。

### for...of原理
`for...of`首先调用对象`[Symbol.iterator]`属性获得一个新的迭代器，迭代就是不断调用`next()`直至迭代结束。在此过程中，提前终止（return、break、异常）会告知迭代器从而避免迭代器永远停在**挂起状态**。

### 异步迭代生成器
本质是通过yield实现**阻塞**

yield暂停不仅可以调用异步函数的返回值，还能捕获异步函数调用的错误

### 生成器委托
```js
function *one () { 
  yield 1
  // 首先创建一个two迭代器，然后yield *将实例委托给two迭代器
  yield *two()
  yield 3
}
function *two () {
  yield 2
}
const it = one()
it.next().value // 1
it.next().value // 2
it.next().value // 3
```
`yield *`转移了迭代器控制，可以转移到任意**iterable**，并且yield会捕获**iterable**中return部分的值。


## ES7
1. async/await


## Q&A
1. 异步控制台输出低效且时延，还有什么调试方法？
    1. 使用`JSON.stringify`可以强制执行一次**快照**
    2. 使用宿主环境提供的调试器
2. 如何判断一个对象是Promise
    1. `p instanceof Promise`：检查具有局限性，对于浏览器环境，Promise对象可能来自其他浏览器窗口（iframe）与当前Promise不同。
    2. `Promise.resolve`
        ```js
        function isPromise (instance) {
        // `Promise.resolve`会将一个非Promise对象包装成`Promise`
        if (Promise && Promise.resolve) return Promise.resolve(instance) == instance
        else throw new Error('Promise not supported in your env!')
        }
        ```
    3. `[[Class]]`
        ```js
        function isPromis (instance) {
        return instance && Object.prototype.toString.call(instance) === '[object Promise]'
        }
        ```
3. 全局捕获Promise错误信息
    Promise链中无论是then还是catch，都是将当前决议的错误抛给下一个Promise，由此可能导致catch中出现的错误无法处理。基于不同的宿主环境，有以下处理方式：
    1. web：监听`unhandledrejection`事件
        ```js
        window.addEventListener('unhandledrejection', event: PromiseRejectionEvent => {})
        ```
    2. NodeJS：监听`unhandledRejection`事件
        ```js
        process.on('unhandledRejection', reson => {})
        ```
4. Ajax、Promise、async/await原理
5. 手撕Promise和async/await
6. 宏任务不存在于规范，而是源自于V8
    对于web，JE在所有任务执行成功后再进行渲染

7. 浏览器环境中queueMicrotask是否是唯一的？
    1. 测试计划
        1. 俩个任务（settimeout）
        2. 每个任务执行多次递归异步任务

## 引用
1. https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth