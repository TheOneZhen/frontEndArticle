# 作用域
作用域规定了查找变量的范围，js采用词法作用域（Lexical Scoping，静态作用域），即由当前执行的作用域一直向上查找，到全局作用域查找完全结束（此过程为作用域链），比如这段代码：
```js
var a = 1
function f1() {
  console.log(a)
}
function f2() {
  var a = 2
  console.log(f1())
}
f2()
```
```js
// 输出
1
```
执行f1的时候，并没有在f2内部找资源，而是在自己所在的环境向上找。
# [变量提升（Hoisting）](https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting)

## 函数作用域
- 由此引申的函数执行步骤（存疑）：
	函数定义后（JE扫描后）：保存作用域链到函数特性[[Scopes]]
	函数执行后，先开始准备工作：创建函数执行上下文栈，相关函数变量入栈，复制函数[[Scopes]]特性创建作用域链
	开始函数执行：平平无奇的入栈出栈
	函数执行完成后：如果存在闭包，通过AST扫描闭包函数，打包闭包需要的资源，闭包函数入栈，原函数无效资源释放

# var、let、const区别

# 作用域链
- 静态作用域链（js设计）
  - 函数和块内的变量声明会在作用域（[[Scopes]]）内创建一个绑定（binding），其它地方对此绑定的引用的访问顺序
    - 与代码顺序强相关
  - 方便做静态分析（tsc、babel）
- 动态作用域链
  - 与执行顺序强相关

# 项目中将全部的var替换为let有什么风险，具体方案
1. 手动替换
2. Babel

# const定义的变量可以被修改吗，如何保证不可修改
1. Object.freeze()
2. TS as const

# 闭包
- 什么是闭包
  - 一个函数可以调另一个函数内的资源
- 闭包创建前后
  - 为了防止部分资源（引用型对象）缺少引用而被销毁，所以闭包之前会执行父函数资源的打包
    - 父作用域销毁不能影响子作用域，但是不销毁父作用域也不行，会造成严重的资源浪费，所以需要打包被调用的资源
    - JE会扫描函数内的标识符，把子作用域中引用的资源打包成Closure链（global链也会打包，俩者形成新函数的外部环境，以支持函数的运行），放到[[Scopes]]特性中
    - 对于eval，因为是动态内容，没法静态分析，所以打包时会打包整个作用域（eval + 闭包性能差的原因）
  - 打包后，JE销毁父函数中无效引用资源
- 资源如何打包
  - AST扫描，JE Lazy Parsing函数（闭包性能差的原因）
- 支持闭包的数据结构
  - [[Scopes]]
    - Closure
      - 存放子作用域引用的资源（闭包专属）
    - Global
      - 存放全局变量引用
  - 闭包类每次实例化都会生成一个单独的作用域，同源实例化变量之间的环境（数据）不会相互影响
  - 此结构为栈，因为闭包函数内部也存在无限调用
- 闭包保存在何处
  - 闭包生成前：存在于引用堆中
  - 闭包生成后：引用会入栈，闭包内新声明的资源会入堆，引用上下文资源的位置不变（堆）
- 闭包导致的内存泄露
  - 闭包函数调用的上下文资源没有使用且不及时释放
- 闭包实现私有函数和变量
> 私有函数：只能在类中被调用，无法在类外被调用
```js
const counter = (function () {
    let count = 0
    function change(val) {
        count += val
    }
    return {
        increment: function () {
            change(1)
        },
        decrement: function () {
            change(-1)
        },
        value: function() {
            return count
        }
    }
})()
```
## 闭包应用
- 柯里化
  - 柯里化复杂了函数执行，但是提高了函数的适用性
  - 实现
    ```js
        function curry (fn) {
            return function curried (...args) {
                if (args.length >= fn.length) {
                    return fn.apply(this, args);
                } else {
                    return function (...args2) {
                        return curried.apply(this, args.concat(args2))
                    }
                }
            }
        }
    ```
  - lodash实现
    ```js
    ```
- 偏函数
  - 函数在调用的时候，不用传入全部函数（部分参数细节被隐藏）
  - 实现
    ```js
    function list() {
        return Array.prototype.slice.call(arguments)
    }
    const mid = list(undefined, 10)
    mid() // [10]
    mid(1, 2, 3) // [10, 1, 2, 3]
    ```

## Q&A
- "use strict"是怎样限定变量调用的

## 引用
1. https://juejin.cn/post/7210614375290863673
2. https://zhuanlan.zhihu.com/p/121558249
3. https://juejin.cn/post/6957913856488243237
4. https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md