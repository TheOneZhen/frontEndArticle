# 类型与语法
## 类型及类型判断
> 类型判断摘抄至lodash，由于lodash的模块化处理，这里我进行了简化汇聚

JS有俩类抽象类型，原始值和对象，抽象类型下各自包含一些成员类型。
- 原始值（[primitive value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#primitive_values)）
    - Undefined
    - Null
    - Boolean
    - Number
    - String
    - Symbol(ES6)
    <!-- BigInt ES10 -->
- 对象（[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#object)）
    - Object

> 注意：要区别**抽象类型object**和**Object**，前者并不存在于JS环境中，后者是标准内置对象。

为什么没有Array、Map这些常用的“类型”呢？

答：它们也是Object的一种，比如初始化一个`Array`，规范是这么解释的（https://tc39.es/ecma262/#sec-array-constructor）：
- is the initial value of the "Array" property of the **global object**
- ... the Array constructor to initialize subclass instances that are **Array exotic objects**.
意思是`Array`是一个特殊的全局对象。

接下来我们看看各个成员类型的一些特点！
### Undefined
Undefined类型只有一个值：undefined。在JS中有以下应用：
- `return;`会隐式返回`undefined`；
- 访问不存在的对象属性（作用域篇：对象属性查找规则）返回`undefined`；
- 访问未声明的变量返回`undefined`（作用域篇，LHS）；
- 未初始化的变量默认值为`undefined`；
- 标准内置对象的一些方法，比如Array.prototype.find(), Map.prototype.get()，默认返回`undefined`；
- [void运算符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void)（`undefined`是变量，存在被修改的风险，建议在函数中使用此代替`undefined`）

类型判断也很直接：
```js
function isUndefined(x) {
  return x === undefined;
}
```

### Null
Null数据类型只有一个值：null，虽然是**primitive value**，但看下面代码：
```js
typeof null // object
typeof {} // object
```
是不是很奇怪？《你不知道的JS》作者认为这是一个不需要修改的bug。那正好，我们也可以利用这个**bug**，让它和`undefined`有一些区别。

MDN对`null`和`undefined`有这么一段阐述（https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#undefined_type）
```
... undefined indicates the absence of a value, while null indicates the absence of an object ...
```
话糙理不糙，让`undefined`代表没有**任何值**，`null`代表没有**任何对象**。从null的应用我们也能加深上述观点，尽管JS中null的应用少得可怜：
- [原型链末端](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)，这个非常重要。从这一处我们也可以看出，为什么null被当作对象来看待
- Object的一些静态方法，比如`Object.create()`，可以将null作为参数传进去；再比如`Object.getPrototypeOf`：
    ```js
    const obj = Object.create(null) // {}。一个纯净空对象，适合存储数据
    Object.getPrototypeOf(obj) // null
    ```
是不是都和**空对象**有关联？不过它们之间还有一个明显的区别：`null`是关键字，`undefined`是全局变量。null做为[关键字](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar)存在，直接被JE识别，不能做任何赋值操作。这是JS语法，介绍null这一特点其实无关紧要，因为开发过程中和`undefined`同等看待的。

Null类型判断很直接：
```js
function isNull(x) {
  return x === null;
}
```

### Boolean
布尔类型包含俩个值：`true`和`false`，多用于条件运算。Boolean类型有很多细节问题，我们需要进行更多的思考，首先看下lodash中类型判断代码：
```js
function isObjectLike (value) {
  return value !== null && typeof value === 'object'
}
function isBoolean (value) {
  return value === true
    || value === false
    || (isObjectLike(value) && Object.prototype.toString.call(value) === '[object Boolean]')
}
```
代码`isObjectLike(value) && Object.prototype.toString.call(value) === '[object Boolean]'`让人很迷惑，其实我们经常用字面量的方式声明Boolean类型，即`let a = false`；还有另一种声明方式`let b = Boolean(false)`，当然如果一些宿主环境可以打印的话，可能像这样：
```js
/** chrome 114.0 */
let b = Boolean(false)
// Boolean {false}
```
虽然它表现的是个对象，但它确确实实是Boolean类型，包括之前提及的字面量声明，最终在JE的表现是这种形式（[装箱](#装箱)，可移步阅读），之后的类型转换我们还有更多的坑要踩。

## String

### String.raw(s: string): string

配合模板使用，内部字符串不会进行任何转义。

### String.repeat(n: number): string

### Number

- [Number.EPSILON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON)：该属性表示一个数字最邻近浮点数与它的差
> 常见面试题《0.1 + 0.2 !== 0.3》中会应用到这个属性。在二进制中也存在无限小数（类比十进制中1/3），但是IEEE精度是有限的，导致遇到这类数字时不得不丢失精度。比如0.3对应的二进制是0.01001100110011...：
```js
    equal = Math.abs(a + b - c) < Number.EPSILON
```
可以理解为在约定的误差下认为它们是相等的。
    
- 数字字面量扩展

    情况有些多，数字转换的时候如果有进制相关的参数最好加上。比如数字转换为字符串时：
    ```js
    const a = 8
    // 等同于a.toString(10)
    a.toString() // '8'
    // 二进制
    a.toString(2) // '1010'
    ```

### Symbol(ES6)
  - 不能使用其他操作符
  - 一般被用来创建匿名且不可枚举的属性
    ```js
      const myPrivateMethod = Symbol();
      this[myPrivateMethod] = function() {...};
    ```
    - 因为不可枚举，无法作为for...in...的成员出现
    - 因为匿名，不能被Object.getOwnPropertyNames()访问，但可以被Object.getOwnPropertySymbols()访问
  - symbol注册表的内容不会出现在js运行环境，只有通过中间方法获取（Symbol.for，Symbol.keyFor()）


## Object

### Object.is()

```js
Object.is = function(v1, v2) {
  // 测试 `-0`
  if (v1 === 0 && v2 === 0) {
    return 1 / v1 === 1 / v2;
  }
  // 测试 `NaN`
  if (v1 !== v1) {
    return v2 !== v2;
  }
  // 其他的一切情况
  return v1 === v2;
}
```

## Array


使用`new Array(number)`会创建`[empty * number]`的数组（以下称**存在空白的数组**），这种数组不同于`[undefined * number]`，它们行为存在一致，但是实际上是不同的东西，对此可做以下处理：
- 如果数组容量小，可以直接使用字面量声明的方式
- 声明空白数组时及时填充初始值，并在之后开发禁用`delete array[index]`方式避免`empty`的出现
- 使用`Array.apply(null, { length: number })`的方式声明数组
- ES6使用`Array.from({ length: number })`，效果同3

### Array.of

### Array#copyWithin(target: number, start: number, end: number): this

### Array#join()

这是`Array#join`的简单实现：
```js
Array.prototype.join = function (connector) {
  let str = ''
  for (let i = 0; i < this.length; ++i) {
    if (i > 0) str += connector
    if (this[i] !== undefined) str += arr[i]
  }
  return str
}
```
从上面的代码也可以理解为什么`Array()`方式声明数组会带来一些歧义：
```js
const a = [undefined, undefined, undefined]
const b = Array(3)
a.join(',') //  , , ,
b.join(',') // (三个空格)
```

**伪数组**

### WeakMap

### 基本数据类型通用特性
- 基本数据类型的值是[不可变](https://developer.mozilla.org/en-US/docs/Glossary/Immutable)的，即任何操作不会改变原始值本身，而是返回对原始值的操作结果
- 拆箱与装箱
  - 基本数据类型是没有属性的，但是在js中，基本数据类型构建后有一些默认的方法属性，且给基本属性加上属性不会抛出TypeError错误
  - 显示拆箱
    - toString()，valueOf()这种
  - 显示装箱
    - 通过构造函数声明基本数据类型
    - 基本数据类型的属性都是装箱（通过构造函数的隐式装箱）时添加的
- 如果是通过对象形式声明基本数据类型，可以直接调用构造函数，无需使用new，但是这样声明的变量不能通过`instanceof`判断实例归属：
    ```js
    const a = String('ha')
    const b = new String('ha')
    a instanceof String // false
    b instanceof String // true
    ```
    
### 引用数据类型
- 对象属性
  - 数据属性
    - [[Value]] = undefined
    - [[Writable]] = false
    - [[Enumerable]] = false
    - [[Configurable]] = false
  - 访问器属性
    - [[Get]] = undefined
    - [[Set]] = undefined
    - [[Enumerable]] = false
    - [[Configurable]] = false

### 基本数据类型和引用数据类型的区别
- 存储区别
  - 引用数据类型引用的数据存储在堆中，但是指针（声明的引用变量）和基础数据类型一样，都是存在栈中

## 语法
<!-- 类型判断主要参考lodash -->

### String
对于**原地修改**变量的方法，比如Array.prototype.splice，无法应用到字符串上

### typeof原理
typeof返回值为`[Object xxx]`，其中`xxx`代表对象的内部属性`[[Class]]`，这个内部属性无法直接访问，可以通过`Object.prototype.toString()`查看。

```js
// 全类型判断方法
function getType (anyType) {
// 过滤null和undefined
if (anyType == null) return anyType + ''
return typeof anyType
}
```

### Symbol
### 装箱
## 抽象值操作（ToPrimitive）
### ToString（这是抽象操作，不是`String#toString()`）
对于对象，首先检查是否存在`valueOf`方法，如果有并返回基本类型值，则使用该值进行强制类型转换；如果没有使用`toString`的返回值进行强制类型转换。如果`valueOf`和`toString`均不返回基本类型值，会产生`TypeError`错误。

`toString`是**强制类型转换**，`JSON.stringify`有许多与其相同的表现：
1. `JSON.stringify`在对象中遇到`undefined`、`function`和`Symbol`会自动忽略，在数组中则返回`null`以单元位置不变；
2. 对象中自定义`toJSON`方法，在被序列化时会自动调用该方法。`toJSON`返回的是一个能被字符串化的JSON值，而不单单是一个字符串：
    ```js
    const a = { b: 10, toJSON: function () { return { b: 10 } } };
    JSON.stringify(a); // '{"b":10}'
    ```

### ToNumber

### ToBoolean
`falsy`的反面即是`truthy`，又一个地方会存在误解，即包含`falsy`的对象，这一点区别于空对象`{}`：
```js
  const a = new Boolean(false);
  const b = new Number(0);
  const c = new String('');
  const d = Boolean(a && b && c); // true
```

## 显示类型强制转换
### 字符串和数字之间的显示转换
1. `+ new Date()`：返回时间戳；ES5之后不建议这种写法，可以使用`Date.now()`，其polyfill：
    ```js
    if (!Date.now) {
    Date.now = function () { return +new Date() }
    }
    ```
2. `~String.prototype.indexOf()`：配合`if`可以强转为`Boolean`，避免出现`>= 0`或`!== -1`这种碍眼的代码，使代码更优雅，比如：
    > 原文中对`~`这类位操作符还有很多描述，但是这类描述过于琐碎，这里没有类举

    ```js
    const str = 'abcdef';
    if (~str.indexOf('c')) { ... }
    ```
3. `~~`：去除小数位；它不是向下取整，不同于`Math.floor`：
    ```js
    Math.floor(-1.6); // -2
    ~~-1.6; // -1
    ```
    而且同很多位运算符一样，只适用于32位数字，对于`~~x`，表现和`x | 0`一致

### 显示解析数字字符串
```js
parseInt(1/0, 19) // 18
```
`parseInt`会对第一个参数进行`toString`强转，`1/0`被转换为`'Infinity'`，然后从左到右解析`'Infinity'`得到`i`，在19进制中代表18.
> 但是`parseInt`存在一个bug，就是以`0x`开头的字符串会被默认解析为8进制，所以在解析时尽量传入第二个参数既定进制

### 显示转换为布尔值
状态转换语句中（三元、`if`、`while`等），应该显示强制类型转换，是代码更明确（优先使用`!!`）

## 隐式强制类型转换
<!-- https://user-images.githubusercontent.com/38256126/124141063-a5c7b400-dabb-11eb-8a8c-2f9503f9f06e.png -->

### 字符串和数字之间的隐式强制类型转换
1. 如果`+`的其中一个操作数是字符串（或者可以通过`ToPrimitive`转换为字符串），执行**字符串拼接**；否则执行数字加法。
2. 根据`ToPrimitive`抽象操作规则：`String`直接调用`toString`；`str + ''`参考line 47
    ```js
    const a = { toString: function () { return 4 } }
    a + '' // "4"
    String(a) // "4"
    a.valueOf = function () { return 42 }
    a + '' // "42"
    String(a) // "4"
    ```
3. 操作符`-`俩端只能是数字：
    ```js
    const a = [3]
    const b = [1]
    a - b // 2
    ```
    首先`a`和`b`通过`toString`转换为字符串，然后字符串通过`ToNumber`再转换为`Number`

### `||`和`&&`
`||`和`&&`首先对第一个操作数执行**条件判断**，如果不是`Boolean`，执行`ToBoolean`，然后再执行条件判断。对于`||`，如果判断结果为`true`就返回第一个操作数的值，否则返回第二个操作数的值；对于`&&`，如果判断结果为true，则返回第二个操作数的值，否则返回第一个操作数的值。

## 宽松相等和严格相等
**`==`允许相等比较中进行强制类型转换，而`===`不允许**。当俩端类型相同时，宽松相等等同于严格相等。当俩端类型不同时，有以下几种情况：
1. `Boolean`和非布尔类型（优先级最高）：对`Boolean`执行`ToNumber`
    ```js
    const a = '42'
    const b = true
    a == b // false
    ```
    上面`true`先触发`ToNumber`变成`1`，也就是`'42' == 1`，然后`'42'`触发`ToNumber`变成`42`，最后对比为`42 == 1`，结果为`false`。整个过程没有涉及`ToBoolean`，也就是相等与俩端是`truthy`还是`falsy`没有关系。
2. 对象和非对象：对对象执行`ToPrimitive`，以下三种情况需要注意：
    1. 基础数据类型的拆箱（boxed）和装箱(unboxed)，主要是使用对应的封装对象，效果同`Object(Primitive)`
    2. `null`和`undefined`没有对应的封装对象，所以`Object(null)`和`Object(undefined)`返回的是常规对象
        ```js
        const a = null
        const b = Object(a) // {}
        a == b // false
        const c = undefined
        const d = Object(d) // {}
        c == d // false
        ```
    3. 因为`NaN != NaN`，所以：
        ```js
        const a = NaN
        const b = Object(a) // NaN，等同于`Number(NaN)`
        a == b // false
        ```
3. `String`和`Number`：对`String`执行`ToNumber`
4. `null`和`undefined`
    ```js
    null == undefined // true
    ```
### 如何优雅的进行宽松相等判断
1. 首先注意运算符优先级：
    ```js
    [] == ![] // true
    ```
    这里先执行的是`![]`，变成`false`，之后**对象和非对象**情况，结果为`true`
2. 遇到不同类型，一定显式强转为相同类型
3. 能用`===`尽可能用，能省去很多事情

### 抽象关系比较（abstract relational comparison）
1. JS中`a <= b`会被处理成`!(a > b)`，意思为a不大于b；`a >= b`会被处理为`!(a < b)`，意思为a不小于b。
2. 关系比较中只有*宽松*，没有严格，所以更应该约束俩端类型

## 语法
1. 语句的结果值（但是JE不允许获取结果值并赋值给其他变量）
    1. var的结果值是`undefined`
    2. 块作用域结果值是最后一个语句的结果值
    3. 对于链式赋值：
        ```js
            var a, b, c;
            a = b = c = 1;
        ```
        上面这种赋值方式是对的，先声明再赋值。但是`a`、`b`和`c`中如果存在变量没有赋值，会导致LHS：
        ```js
        {
            let a = b = c = 1;
        }
        a // undefined
        b // 1
        c // 1
        ```
        之后的代码风格中一定要规避这种！
### 上下文规则
1. 标签（和块作用域有很大联系）
    1. 循环中经常出现的`break`和`continue`后面可以跟随一个标签（默认是当前块作用域），
    ```js
    tag1: for ( ... ) {
      if ( ... ) break tag1; // 跳出tag1
      if ( ... ) continue tag1; // 继续执行tag1
    }
    ```
    比如上面的伪代码.对于多层循环想要一次性break出去，标签语句很有用，当然对于`break`，在标签中不使用循环也能单独使用。
    2. 标签语法考验JSON：在浏览器控制台中直接输入JSON格式代码会被误认为标签语法，代表JSON不是合法的js语法，这就会导致开发过程中如果直接导入`.json`格式的文件，可能会出现未知错误。于是延伸出JSON-P：将JSON传递给函数从而实现其调用。
2. 代码块
    ```js
    [] + {} // '[object Object]'，这里{}会被看成空对象，然后显示强转为`'[object Object]'`，表达式变成`'' + '[object Object]'`
    {} + [] // 0，这里{}被看成空代码块（没有结果值），表达式变成`+''`
    ```
3. 对象解构（ES6）

    ```js
    const { a: a1, b: b1 } = fn() // 或const { a, b } = fn()
    ```
    这里是将`a`的值给`a1`。解构赋值不仅可以声明，还能修改已定义变量的值：
    ```js
    let a , b
    [a] = fn1()
    ({ b } = fn2()) // 对象必须要加上括号，不然会被识别为标签语法
    ```
    还可以进行重复赋值：
    ```js
    const { a: a1. a: a2 } = fn()
    ```
### 运算符优先级
1. 短路
    ```js
    a && b // 如果a是truthy，直接返回b的值；反之直接返回a的值
    a || b // 如果a是truthy，直接返回a的值；反之直接返回b的值
    ```
2. 优先级：具体优先级参考https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence，这里有一点**可选链**优先级是18，比`&&`高
3. 关联：除了优先级，还有从左到右的顺序级（主要是因为JS语法的副作用）。这里有左关联和右关联俩种，右关联有：看上面那个链接里面的
### 自动分号插入（ASI，Automatic Semicolon Insertion）
插入依据和语法、换行符强相关

### 错误
### 提前使用变量
暂时性死区（TDZ，Temporal Dead Zone，ES6），指变量没有初始化不能被引用。

但是函数参数中使用TDZ有特殊情况：
```js
function fn (a = 1, b = a + 1) { ... } // 如果传入参数是undefined，使用默认值
```
参数`b`可以访问参数`a`，此时已经跳出参数`a`的TDZ。

对于参数默认值，如果不传入参数，`arguments`为空，这也是ES6不推荐`arguments`的原因之一。

### try...finally
`finally`总是在`try`之后执行，即使`try`中包含`return`、`break`、`continue`、`yield`、`throw`，像一个回调函数一样。比如：
```js
(function () {
    try { return 42 }
    finally { throw "run here" } // 即使`try`中执行了`return`，但在`finally`中还是被驳回
    console.log('not run here')
})()
/**
 * Uncaught Exception: run here
 */

(function () {
    try { return 42 }
    finally { return "run here" } // 使用`finally`中`return`的结果
    console.log('not run here')
})()
/**
 * run here
 */

(function () {
    try { return 42 }
    finally { return } // 如果`finally`中`return`为`void`，则使用`try`中`return`的结果
    console.log('not run here')
})()
/**
 * 42
 */

(function () {
    tag1: try { return 42 }
    finally { break tag1 } // 和标签的配合会出现剧烈的火花！！
    console.log('not run here?')
})()
/**
 * not run here?
 */
```
> ES6中新加入的`yield`在`generator`重新开始时才结束，导致`finally`不会在`yield`之后立即执行.

### switch
```js
switch (state) {
  case condition: ...
  default: ...
}
```
`condition`可以是表达式，也可以是原始值，state和condition通过`===`（严格相等）进行判断，所以如果`condition`是表达式则返回类型必须是`Boolean`，不然会强转相关的错误。比如：
```js
switch (a) {
  case (a || 2):
    console.log('run here') // 无法执行到这里
    break
}
```

### 扩展运算符（spread/rest）

```js
const a = [1,2,3]
b = [...a] // spread

function fn (...args) {} // rest
```

### 模板字面量
#### 插入表达式

模板字面量可以被当作IIFE，作用域处理同IIFE是一致的。

#### 标签模板字面量

参看下面这段代码：
```js
function fn (arg1, ...rest) {
  console.log('arg1: ', arg1)
  console.log('rest: ', rest)
}
const param1 = 'daye'
const param2 = 'welcome'
fn `hi ${param1}, ${param2} to my house!`
// arg1: ['hi ', ', ', ' to my house!']
// rest: ['daye', 'welcome']
```
`fn xxxx`也是函数的一种调用方式。通过观察可以发现，模板内**字符串**被**插入字符串**切割成了**插入字符串数量 + 1**部分并作为函数的第一个参数，**插入字符串**作为剩余参数。

## 全局DOM变量
创建带有id属性的DOM元素也会创建同名的全局变量，也就是为什么前端js框架中没有声明app却自动出现app全局变量的原因。

## `<script>`
这个标签像全局作用域下一个单独的作用域。

## js在不同宿主环境的统一限制
- 字符串常量中允许的最大字符数（并非只是针对字符串值）；
- 可以作为参数传递到函数中的数据大小（也称为栈大小，以字节为单位）；
- 函数声明中的参数个数；
- 未经优化的调用栈（例如递归）的最大层数，即函数调用链的最大长度；
- JavaScript 程序以阻塞方式在浏览器中运行的最长时间（秒）；
- 变量名的最大长度。

## ES10
### BigInt
  - 与Number相互运算，会抛出TypeError
  - 不符合IEEE 754
  - 与Number之间的转换会存在精度丢失，浮点数也有精度丢失的情况

# Q&A

- 项目中将全部的`var`替换为`let`有什么风险，有无推荐方案？
- const定义的变量可以被修改吗，如何保证完全不可修改？
- 函数声明和函数表达式的区别及使用?（语法篇）
   1. 函数表达式变量名不会暴露给表达式所在的作用域
   2. 函数表达式语法（注意，这俩种写法在作用域提升方面有很大的不同）
      ```js
        // 自执行
        (function test() {...})()
        (function test() {...}())()
        (function () {...}())()
        // 通过变量的方式声明函数，函数表达式不会暴露给a所在的作用域，所以外部访问test会ReferenceError
        const a = function test() {}
      ```

      
# 引用
1. https://developer.mozilla.org/
2. https://github.com/getify/You-Dont-Know-JS/tree/1st-ed
3. https://www.ecma-international.org/publications-and-standards/standards/ecma-262/
4. lodash