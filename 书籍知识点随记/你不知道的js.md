目录同这本书是完全合理的，但是接下来我要考虑的是读完这本书，我要获得什么以及向他人传达什么样的知识体系。但是由于个人学习前端不够系统，导致目前我无法清除读完这本过程中会发生什么，所以：
1. 首先读完上中卷
2. 然后在下卷去总结知识点
本篇将作为疑难知识点记录存在
希望之后有时间能把英文版阅读一遍，加深印象
<!-- ------------------------------------------------------------------------------------------------------------------- -->、
作者是以怎样的角度去分析js的，目前不得而知。在阅读过程中希望我能发现这个问题
<!-- ------------------------------------------------------------------------------------------------------------------- -->

1. 前端编译器感觉可以单独出篇文章
2. 作用域是一个单独的线程吗，在内核中是如何存在的（物理）？
   1. JE查询作用域？还是说作用域是单独的线程
   2. 作用域有多个吗，JE是如何进行调度的
3. 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定
   1. 这里和this不同
4. 函数声明和函数表达式的区别及应用
   1. 函数表达式变量名不会暴露给表达式所在的作用域
   2. 函数表达式写法（注意，这俩种写法在作用域提升方面有很大的不同）
      ```js
        // 自执行
        (function test() {...})()
        (function test() {...}())()
        (function () {...}())()
        // 通过变量的方式声明函数
        const a = function test() {} // 函数表达式不会暴露给a所在的作用域，所以外部访问test会ReferenceError
      ```
5. 块作用域
   1. if，for等
   2. try-catch
      1. 会形成单独的块作用域，
6. 对于`var a = 1`，其中定义声明`var a`是在编译阶段进行的，赋值声明`a = 1`在执行阶段进行
   1. 那是否可以延申
7. js与数据结构
   1. 从数据结构层面探寻js如何实现各种原理的（比如闭包，作用域）

<!-- 第一部分看完了，前面对内核的介绍挺感兴趣，后续的很多内容都是我接触过的，而且没有在浏览器（JE，编辑器）角度去介绍这些原理的实现，有点遗憾 -->

1. this是在运行时绑定的，不是在编译时，所以脱离了词法作用域
   1. 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到
   2. 上面这一点需要和DS结合起来
2. this的指向一般理解为调用函数的位置，实际上存在一些复杂场景
   1. 比如函数嵌套，this指向当前执行函数的上一个函数
3. 之前一直没有注意到严格模式，之后需要细究
   1. 严格模式下，this不会默认绑定全局作用域
4. 隐式绑定和隐式丢失
  ```js
  function foo() {      console.log( this.a ); }  
  var obj = {      a: 2,     foo: foo  };  
  var bar = obj.foo; // 函数别名
  var a = "oops, global"; // a 是全局对象的属性
  bar(); // "oops, global"
  ```
5. 构造函数
   1. new只是一个语法糖，声明一个函数需要被**构造调用**
   2. 步骤
      1. 创建（或者说构造）一个全新的对象。
      2. 这个新对象会被执行[[ 原型]] 连接。（这一步还不详细）
      3. 这个新对象会绑定到函数调用的this。
      4. 如果函数没有返回其他对象，那么new 表达式中的函数调用会自动返回这个新对象。
6. 全局对象捕捉
   1. 对于需要进行绑定的方法，介错全局对象才是最好的办法