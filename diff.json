{"A":{"Node包管理（npm）":{"title":"Node包管理（npm）","content":"## package and module\r\n\r\n- `package`可能是一个文件或者一个文件夹，但是必须有`package.json`文件来描述这个包。\r\n- `module`可能是一些js文件，或者是一个文件夹，但这个文件夹中必须包含`package.json`文件，且`package.json`中包含`main`字段。`module`必须放在项目`node_modules`目录下，且可以通过CJM或者ESM的方式导入。\r\n\r\n\r\n"},"随手记":{"title":"随手记","content":"```zhenisbusy\r\n{\r\n    \"title\": '瞎写的',\r\n    \"time\": 1\r\n}\r\n```\r\nloader是链式调用的，上一个loader的解析结果会传递给下一个loader\r\n\r\n# 开发环境\r\n\r\n1. 如何检错\r\n    1. dedvtool: 'inline-source-map'\r\n        1. source map\r\n2. hot fresh\r\n\r\n# 代码分离\r\n    \r\n1. 防止重复\r\n    1. 入口依赖\r\n        \r\n        在不同Entry中配置依赖的文件，webpack会根据重复依赖进行chunk，进而生成不同的bundle\r\n\r\n        https://www.webpackjs.com/guides/code-splitting/#entry-dependencies\r\n\r\n        用户访问的时候如何调用资源呢？\r\n        \r\n            推测是在每个主bundle中引用共享bundle\r\n\r\n    2. splitchunksPlugin\r\n\r\n        上面那种方式会多生成一个runtime.bundle.js，为什么\r\n    \r\n2. 预先获取（prefetch）和预先加载（preload）\r\n\r\n    使用`/* webpackPrefetch: true */`注解动态导入资源：\r\n\r\n    ```js\r\n    import(/* webpackPrefetch: true */'else.js')\r\n    ```\r\n\r\n    会在当前entry（html文件）顶部生成`<link rel=\"prefetch\" href=\"else.js\" >`，当主体chunk完成加载（load），再加载prefetch hint。\r\n\r\n\r\n    `import(/* webpackPreload: true */ 'ChartingLibrary')`\r\n\r\n    \r\n# 创建library\r\n\r\n    ```js\r\n    output: {\r\n      library: 'libraryName'\r\n    }\r\n    ```\r\n\r\n    然后会生成`<script src=\"./libraryName.js\">`这样的标签，就可以在浏览器下文调用此library。\r\n\r\n# 构建性能\r\n\r\n1. 让loader解析它能解析的文件\r\n\r\n    ```js\r\n    ...module: {\r\n      rules: [\r\n        {\r\n          test: '/.js$/', // 指定文件名\r\n          include: path.resolve(__dirname, 'src'), // 指定需要解析的文件目录\r\n          loader: 'babel-loader'\r\n        }\r\n      ]\r\n    }\r\n    ```\r\n\r\n2. 减少不必要的loader/plugin的使用\r\n3. 解析（https://www.webpackjs.com/guides/build-performance/#resolving）\r\n\r\n# 依赖管理\r\n\r\n1. webpack支持动态require\r\n\r\n    webpack会将目标目录下的所有文件包括子代文件变成`map`\r\n\r\n2. require.context\r\n\r\n    ```js\r\n    require.context(\r\n      directory, // 目标目录\r\n      (useSubdirectories = true), // 是否搜索子代\r\n      (regExp = /^\\.\\/.*$/), // 文件名匹配\r\n      (mode = 'sync') // 是否异步\r\n    );\r\n    ```\r\n\r\n# tree-shaking\r\n\r\n1. side-effect-free\r\n\r\n    如果所有文件都是ESM，且项目中所有导入导出没有副作用（effect），可以设置`package.json`:\r\n    ```json\r\n    {\r\n      \"sideEffects\": false\r\n    }\r\n    ```\r\n    这样可以简单告诉webpack，可以放心大胆的tree-shaking，或者使用数组来忽略一些文件。一般地，CSS Module是需要忽略的，因为它们并不是对象，而是在开发/生成环境通过标识替换而成。\r\n\r\n2. usedExports\r\n\r\n    可以通过`/*#__PURE__*/`注解没有副作用的内容，当该内容导出时会参与tree-shaking。\r\n\r\n    将函数调用标记为无副作用：\r\n\r\n        `optimization.innerGraph: true`，会将无用的函数参数标记为死代码，然后被压缩工具清除掉\r\n\r\n# shimming预置依赖\r\n\r\n    预置全局变量、设置文件作用域、\r\n\r\n# 其他问题\r\n\r\n- bundle、module、chunk"}},"M":{"todo":{"title":"todo","content":"# 文章目录结构设计\r\n\r\n- 列表引出（：）、标题(`#`)、列表(`1.`)、块(`>`)、文本结束后需要隔一行\r\n- tab是四个空格\r\n- 对于标题\r\n    - 范围`# - ###`再多网页和vscode表现不明显\r\n- 内容\r\n    - 背景区块：正常文本介绍，引出以下内容\r\n        - 特点、特征\r\n        - ...特殊API介绍\r\n            - 场景分析（介绍） + 源码（polyfill）\r\n        - 其他\r\n\r\n# 留白\r\n\r\n1. 性能优化相关\r\n    1. props更新时会导致组件的刷新，对于容器来说，单个容器元素的更新会导致容器内全部组件重新渲染\r\n    2. 可以加入状态转换props，使组件在必要的时候更新或者卸载\r\n    3. 或者使用v-once或v-memo指令\r\n    4. 虚拟列表\r\n    5. shallowRef与shallowReactive斩断深层响应式\r\n    6. 避免组件树超功能多次调用（VNode是性能优化关键）\r\n2. ts类型检查理解\r\n    1. 开发过程中的类型检查\r\n    2. vscode内置ts语言服务实例\r\n    3. volar（外部插件）ts语言服务实例\r\n    4. 编译过程中的类型检查\r\n    5. webpack：只是单文件的检查，不能介入全局\r\n    6. vite\r\n3. vue类型检查\r\n    1. vue编译器不会抓取导入的文件进行分析源类型，所以导入的module不能做为props泛型（defineProps<{}>()）\r\n    2. props使用基于类型的声明时，不能赋默认值，需要调用额外的方法widthDefault\r\n    3. provide/inject类型标注需要借助InjectionKey（继承自Symbol的泛型类型）\r\n    4. 如何获取组件返回值类型（defineExpose1）：<InstanceType<typeof Component>>\r\n    5. 扩展全局属性\r\n4. postCss\r\n5. Web Worker\r\n6. WebAssembly\r\n7. 打包过程中chunk的作用\r\n8. AMD、CommonJS、UMD、ESM\r\n9.  对vite构建的理解\r\n    1. vite使用EsBuild预构建源码\r\n    2. 索引Module依赖\r\n    3. 将CommonJS 或 UMD 转换为ESM\r\n10. ESM\r\n    1. 具名导入优点：有效支持TreeShaking\r\n    2. 动态导入\r\n        1. import写在顶部与动态导入的区别\r\n11. URL构造器\r\n    1. url变基\r\n12. 工程化\r\n    1. 多页面使用相同组件，如何打包\r\n13. https://developer.chrome.com/blog/inside-browser-part1/\r\n    1. a series knowledge of browser internal architecture that is separed four partition and this is first part\r\n    2. it include many cartoon images funny and detail\r\n14. 事件中执行的函数和普通函数有什么区别，比如a标签中会阻碍href的跳转等，以及为什么非空返回值会导致内存泄漏？\r\n\r\n# list\r\n\r\n- 简历内容梳理（最好每天都进行一次）\r\n- 不同宿主环境下的事件循环（文章）\r\n- 网站博客内容结构调整（非面试内容）\r\n    - 二级域名（t）\r\n    - 工程化相关实践\r\n        - 资源结构调用优化\r\n            - 文章编写的时候可以直接通过文章名链接文章，打包的时候替换成domain + article name\r\n            - 打包的时候把所有的静态文件收纳到静态服务器中，并替换路径\r\n        - 打包\r\n            - 捕捉引用的资源到单独目录\r\n            - 捕捉文章到单独目录\r\n        - 更新\r\n            - 文章前面添加标识，拥有标识的才打包（探索一下有什么办法能知道每次更新了哪些文件，减少不必要的更新）\r\n- 完成Vue设计与实现（文章）\r\n    - 降低优先级，应该优先篇阅读以备面试所需\r\n\r\n\r\n今日大致内容：工程化实践，然后再根据已有知识点补充简历，根据简历筛选薄弱知识点，进行补充。\r\n- vite插件\r\n- webpack loader\r\n    - 文章工程化打包\r\n    - 最后生成俩个目录，静态资源文件（图片等）上传到服务端static.。\r\n    - 文章相关内容重新构建，生成动态内容，触发脚本执行内容插入。\r\n\r\n> !!!!!!!!!!!!!基础面试题的目的不是为了一问一答，而是枚举问题，以及在问题之间产生关联\r\n\r\n\r\n"},"vue设计与实现——编译器":{"title":"vue设计与实现——编译器","content":"# 编译器概览\r\n\r\n编译器的作用是将模板（template）编译成渲染函数（render）\r\n\r\n```js\r\nconst TemplateStr = `\r\n<template>\r\n  <div>\r\n    <p>这是一行文本</p>\r\n  </div>\r\n  <custom-com>这是一个自定义组件</custom-com>\r\n</template>\r\n`\r\n```\r\n\r\n## Parse：template-> template AST\r\n\r\n解析器（parser）用来将模板字符串解析为模板AST。模板字符串来自Vue-SFC，一般由Loader提供，比如WebPack的[Vue-Loader](https://github.com/vuejs/vue-loader#what-is-vue-loader)和Vite的[plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue)。模板AST就是模板字符串的JS对象树形式，以支持之后其他编译函数使用。\r\n\r\n```ts\r\n/** parse返回值类型，为了避免代码混乱，没有将注解加进去 */\r\ninterface ASTNode {\r\n  type: string\r\n  tag: string\r\n  children: ASTNode[]\r\n  content: string\r\n}\r\n\r\nfunction parse (str) {\r\n  const tokens = tokenize(str)\r\n  const root = { type: 'root', children: [] }\r\n  const stack = [root]\r\n  \r\n  while (tokens.length) {\r\n    const parent = stack[stack.length - 1]\r\n    const t = tokens[0]\r\n    switch (t.type) {\r\n      case 'tag':\r\n        const elementNode = {\r\n          type: 'Element',\r\n          tag: t.name,\r\n          children: []\r\n        }\r\n        parent.children.push(elementNode)\r\n        stack.push(elementNode)\r\n        break\r\n      case 'text':\r\n        const textNode = {\r\n          type: 'Text',\r\n          content: t.content\r\n        }\r\n        parent.children.push(textNode)\r\n        break\r\n      case 'tagEnd':\r\n        stack.pop()\r\n        break\r\n    }\r\n    tokens.shift()\r\n  }\r\n\r\n  return root\r\n}\r\n\r\n/**\r\n * 对于普通的HTML元素由三部分组成：开始标签、文本内容和结束标签，tokenize也是围绕它们进行\r\n * 注：tokenize本质是有限状态机，这里我为了代码简洁使用了正则表达式，有限状态机demo可以参考https://github.com/HcySunYang/code-for-vue-3-book/blob/master/course6-%E7%BC%96%E8%AF%91%E5%99%A8/code-15.2.html 。\r\n */\r\nfunction tokenize (str) {\r\n  const result = []\r\n  const re = /<[a-z\\-]+>|(?<=\\>).*(?=\\<)|<\\/[a-z\\-]+>/g\r\n  const matched = str.match(re)\r\n  if (matched) {\r\n    Array.from(matched).map(token => {\r\n      if (token.startsWith('</')) result.push({ type: 'tagEnd', name: token.replace(/<\\/|>/g, '') })  \r\n      else if (token.startsWith('<')) result.push({ type: 'tag', name: token.replace(/<|>/g, '') })\r\n      else result.push({ type: 'text', name: token })\r\n    })\r\n  }\r\n  return result\r\n}\r\n```\r\n\r\n> Vue解析场景十分复杂，上述代码只是简单实现，Vue parse源码[地址](https://github.com/vuejs/core/blob/main/packages/compiler-core/src/parse.ts)。\r\n\r\n## Transform：template AST -> JS AST\r\n\r\n```js\r\nfunction transform(root, options) {\r\n  const context = createTransformContext(root, options)\r\n  traverseNode(root, context)\r\n  // 对节点进行静态提升：https://cn.vuejs.org/guide/extras/rendering-mechanism.html#static-hoisting\r\n  createRootCodegen(root, context)\r\n  root.hoists = context.hoists\r\n}\r\n/** 创建转换器上下文 */\r\nfunction createTransformContext (root, option) {\r\n  const context = {\r\n    parent: null,\r\n    replaceNode(node) {\r\n      context.parent.children[context.childIndex] = context.currentNode = node\r\n    },\r\n    removeNode(node) {\r\n      const list = context.parent.children\r\n      const removalIndex = list.indexOf(node)\r\n      list.splice(removalIndex, 1)\r\n    }\r\n  }\r\n  return context\r\n}\r\n/** 深度遍历子节点 */\r\nfunction traverseNode (root, context) {\r\n  context.currentNode = node\r\n  const { nodeTransforms } = context\r\n  const exitFns = []\r\n  for (let i = 0; i < nodeTransforms.length; i++) {\r\n    const onExit = nodeTransforms[i](node, context)\r\n    if (onExit) {\r\n      if (isArray(onExit)) exitFns.push(...onExit)  \r\n      else exitFns.push(onExit)\r\n    }\r\n    if (!context.currentNode) return  \r\n    else node = context.currentNode\r\n  }\r\n  for (let i = 0; i < parent.children.length; i++) {\r\n    const child = parent.children[i]\r\n    context.parent = parent\r\n    context.childIndex = i\r\n    traverseNode(child, context)\r\n  }\r\n  context.currentNode = node\r\n  let i = exitFns.length\r\n  while (i--) exitFns[i]()\r\n}\r\n/** 进行下一步，生成渲染函数 */\r\nfunction createRootCodegen()\r\n```\r\n"},"基础面试题":{"title":"基础面试题","content":"# CSS\r\n\r\n1. 如何实现一个元素的水平垂直居中\r\n    1. son：absolute + transform(tanslate)\r\n    2. container(flex) + son(margin: auto)\r\n    3. container(grid) + son(margin: auto)\r\n\r\n2. 响应式布局\r\n    > 主轴和交叉轴都可能有多个\r\n\r\n    1. Multicol（多列）\r\n        1. column-count：列数\r\n        2. *-gap：间隙\r\n        3. *-rule：添加分割线\r\n        4. break-inside：多列布局下内容盒子如何中断\r\n    2. Flex Box（弹性盒）\r\n        1. flex-direction\\wrap\\\r\n        2. flex = grow shrink basis\r\n        3. flex-basis在纵向排列时代表height，为最优选\r\n    3. Grid\r\n        1. 1fr，一份\r\n    4. align-content：分配**多行内容**交叉轴方向剩余空间\r\n    5. justify-content：分配主轴方向剩余空间\r\n    6. justify-items：设置容器内每个元素主轴方向的justify-self\r\n    7. justify-self: 设置元素相对于其交叉轴的对齐方式\r\n    8. align-items: 设置每个元素的align-self\r\n    9.  align-self：设置元素相对于其所在主轴对齐方式\r\n    10. place-content = align-content justify-content\r\n    11. place-items = align-items justify-items\r\n3. 标准盒和怪异盒\r\n\r\n    content-box'width = content\r\n    border-box'width = border + padding + content\r\n\r\n4. FC（文档流，Formatting Context）\r\n\r\n    页面中的一块渲染区域，有自己的渲染规则，决定其子元素如何布局以及和其他元素之间的关系和作用。\r\n\r\n    1. BFC（区块格式化上下文，Block Formatting Context）（GFC、FFC也是一个BFC）\r\n        \r\n        块级盒子布局时，BFC为其提供隔离环境，使其不影响容器外布局，元素在这个环境中按照一定规则进行布局。\r\n\r\n        1. 创建： 根元素、浮动元素、悬浮元素、display: flex\\inline-block\\table\\grid、overflow：hidden|auto|scroll\r\n        2. 特性：\r\n            1. BFC 是一个独立的容器，容器内子元素不会影响容器外的元素。反之亦如此。\r\n            2. 盒子遵照一些规则有序排列\r\n            3. 相邻盒子margin-top-bottom会发生重叠\r\n            4. BFC包含浮动元素时（另一个BFC），浮动元素也会参与区域高度计算\r\n        3. 作用\r\n            1. 清除浮动（或使用clearfix）：浮动元素会覆盖普通文档流，但是不会覆盖BFC\r\n            2. 阻止margin-top\\margin-bottom合并：外部元素不会影响BFC布局\r\n            3. 阻止容器高度塌陷：浮动元素参与区域高度计算\r\n    2. IFC（行级格式化上下文）\r\n\r\n        行级元素包括：a\\img\\picture\\span\\input\\select\\textarea\\label\r\n\r\n        1. 创建：块级元素中仅包含行内元素\r\n        2. 特性：\r\n            1. 水平横向排列，垂直方向起点是父元素顶部\r\n            2. 只计算横向样式（ml\\mr\\pl\\pr\\border），行高由CSS行高计算规则来确定\r\n            3. 垂直方向可使用（vertical-align）进行布局\r\n            4. 如果宽度小于容器宽度，由text-align决定水平分布，超出容器宽度可以会溢出，可以设置white-wrap换行。\r\n\r\n5. CSS伪类和伪元素\r\n    \r\n    伪元素会在文档流生成新的元素，使用content属性可以设置内容\r\n\r\n    伪类可以定义元素在不同状态下的样式，或者选择元素（比如：is ：not：has）。\r\n\r\n6. CSS样式优先级\r\n\r\n    内联样式 > ID选择器 > 类选择器（类、属性选择器、伪类） > 类型选择器（标签、伪元素）\r\n\r\n    ！importment会破坏CSS specificity\r\n\r\n7. aspect-ratio：规定盒子首选纵横比\r\n8. animation偏向于主动，transition有点被动\r\n\r\n# 浏览器\r\n\r\n1. 从输入url到展示页面浏览器做了那些事情。\r\n    1. 根据URL获取IP地址，可能是本地缓存，也可能是进行DNS查询\r\n    2. TCP握手\r\n    3. TLS协商（Transport Layer Security）\r\n    4. 浏览器获取资源\r\n        1. 如果本地存在缓存，判断缓存是否过期，如果没有过期，复用。如果过期发送Get请求获取资源。\r\n        2. 如果本地不存在缓存，发送GET请求获取资源\r\n    5. 如果资源是HTML。开始解析\r\n        1. 解析之前进行一次预加载扫描\r\n            1. 如果遇到preload资源，请求获取资源\r\n            2. 如果遇到CSS、JS文件，请求获取资源\r\n        2. 解析HTML生成DOM\r\n            1. 如果遇到CSS文件，请求资源\r\n            2. 如果遇到script文件\r\n                1. 如果是defer，请求资源，并在HTML解析之后执行脚本\r\n                2. 如果是async，请求资源，待资源下载完毕立即执行脚本\r\n                3. 如果都没有，阻塞HTML解析，一直到脚本下载完毕并且执行完毕\r\n        3. 触发domcontentLoaded事件\r\n        4. 解析完毕后开始构建CSSOM\r\n            1. 如果有CSS文件没有下载完全会阻塞渲染\r\n            2. 如果CSS文件中包含@import，阻塞渲染，下载文件\r\n        5. DOM和CSSOM合并成render tree\r\n            1. 布局：从Render Tree根节点开始，确定节点的大小和位置\r\n            2. 绘制：将可见部分绘制到屏幕上\r\n            3. 合成：将文档中不同层按正确的顺序合并到一起\r\n        6. 触发load事件\r\n    6. 页面展示。\r\n    \r\n2. 什么是跨域，同源策略。如何解决\r\n\r\n    跨域资源共享（CORS）\r\n\r\n    1. 服务器响应头添加：Access-Control-Allow-Origin: *\r\n    2. 反向代理中配置目标域名（或资源路径）（服务器代理请求的资源）\r\n    3. JSONP\r\n        \r\n        HTML src属性引用资源不会触发SOP（同源策略），\r\n\r\n        ```js\r\n        function jsonp(url, params, CB) {\r\n          const script = document.createElement('script')\r\n          script.src = `${url}?${stringify({ callback: \"padding\", ...params })}`\r\n          window['padding'] = CB\r\n          document.body.appendChild(script)\r\n        }\r\n3. preload与prefetch\r\n    1. preload用于提前加载当前界面资源\r\n        1. 浏览器在解析HTML的时候会识别此属性优先加载资源\r\n    2. prefetch用于提前加载其他界面资源\r\n4. 异步加载脚本async与defer\r\n    https://html.spec.whatwg.org/images/asyncdefer.svg\r\n    async在脚本下载完后，立即执行（可能会阻塞HTML解析）\r\n    defer在异步下载脚本，并在HTML解析之后，DomContentLoaded之前执行\r\n\r\n5. DomContentLoaded与load\r\n    1. HTML解析完成后，DomContentLoaded事件触发\r\n    2. 当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件\r\n6. 如何取消请求的发送\r\n    1. XHR：XMLHttpRequest.abort()\r\n    2. fetch: AbortController\r\n    3. axios: cancelToken\r\n7. 浏览器使用ESM\r\n    1. Module默认defer\r\n    2. Module是单独作用域，不会污染到全局（IIFE）\r\n    3. Module是strict\r\n8. window\r\n    1. requestIdleCallback：在浏览器空闲的时候执行函数（一般用于低优先级的任务）\r\n    2. requestAnimationFrame：在浏览器下一次重绘之前调用指定函数更新动画\r\n    3. postmessage：进程间通信\r\n    4. queuemicrotask：微函数执行栈\r\n    5. matchMedia\r\n    6. getSelection\r\n9. iframe（微前端篇）\r\n10. 图形绘制\r\n    1. svg\r\n        1. 矢量图形、可以添加事件处理器、可以使用css、结合Vue相对简单\r\n        2. 性能差，不适合渲染大量动态图形\r\n    2. canvas\r\n        1. 只能绘制栅格图形，不能绘制矢量图形、不支持事件处理器、缩放困难、动画需要手动实现\r\n        2. 性能好（只考虑结果，不考虑过程）\r\n11. 请求\r\n    1. XMLHttpRequest\r\n    2. fetch\r\n\r\n# 计算机相关\r\n\r\n1. TCP\r\n    1. 三次握手\r\n        1. 客户端发送SYN\r\n        2. 服务端接收SYN，响应SYN-ACK\r\n        3. 客户端发送SYN\r\n    2. 四次挥手\r\n        1. 客户端发送FIN\r\n        2. 服务端接收FIN，响应ACK\r\n        3. 服务端发送FIN\r\n        4. 客户端收到后发送ACK\r\n    3. 请求头\r\n        1. keep-alive：可以在一个TCP连接上发送多个请求，减少TCP连接开销\r\n2. 安全（这里总结的不是很详细）\r\n    1. SOP\r\n    2. CSP：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\r\n    3. CSRF攻击：恶意伪造请求。cookie的samesite\r\n    4. HSTS策略：可以强制浏览器使用HTTPS进行通信，可以减少重定向造成的额外请求和会话劫持风险\r\n3.  http缓存\r\n    1.  cache-control\r\n        1. cache-control请求头包含属性：max-age、no-cache、no-store \r\n        2. no-cache与no-store区别\r\n            1. no-cache可以在客户端缓存资源，但是每次都必须请求服务器检查新鲜度，来决定是从服务器获取最新资源（200）还是从客户端读取缓存（304），即协商缓存\r\n            2. no-store不使用任何缓存\r\n    2. 强缓存：通过cache-control中max-age控制。不会向服务器发送请求\r\n    3. 协商缓存：访问缓存前需要进行新鲜度校验（有些不清晰）\r\n        1. 通过比对etag和if-none-match\r\n        2. if-modifie-since和last-modified和对比\r\n4.  http2：https://juejin.cn/post/6844903667569541133\r\n    1. http/1.1缺点\r\n        1. TCP连接数限制：对于同一个域名，浏览器只能创建几个TCP连接，所以一般是同一个域名创建几个子域名来增加TCP连接数\r\n        2. 线头阻塞（Head Of Line Blocking）：每个TCP连接同时只能处理一个请求，如果当前请求响应阻塞，后续请求都会受阻。\r\n        3. Header内容多且不会压缩，每次请求都需要携带\r\n        4. 明文传输不安全\r\n    2. http2优势\r\n        1. 二进制分帧层（Binary Framing Layer）\r\n            \r\n            报文消息被划分为更小的数据帧\r\n        \r\n        2. 多路复用：http/1.1中的帧可以在一次TCP连接中组合成流发送，而不需要创建多个TCP发送\r\n            \r\n        3. 服务端推送（server push）：客户端还没有请求，服务端就把一些必要的内容推送过去：http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html\r\n        4. Header压缩（HPACK）\r\n        5. 应用层的重置连接：可以在不断开连接的前提下取消stream\r\n        6. stream请求优先级\r\n        7. 流量控制\r\n5.  https = http + tls\r\n    1. http缺点：http内容使用明文传输，在传输过程中被劫持后传输内容完全暴露。不能判断数据是否被篡改。\r\n        1. 数据明文传输\r\n        2. 缺乏消息完整性检测\r\n    2. https使用对称加密和非对称加密（CA数字签名 + 数字证书用于证明密钥的真伪）\r\n    3. TLS协商\r\n        1. 客户端发送请求并携带密码组合、随机数1\r\n        2. 服务端响应密码组合和CA证书、随机数2\r\n        3. 客户端发送随机数3，密钥生成\r\n        4. 双方互发FIN\r\n    4. 每次https请求都需要生成密钥吗\r\n        1. 不会，服务器会为每个浏览器生成sessionId，在TLS握手阶段传给浏览器，之后浏览器的请求自动带上sessionId\r\n6. base64\r\n    1. 字符构成：a-z、A-Z、0-9、+、/\r\n7.  cookie访问范围\r\n    1. 包含的属性domain、expire（max-age）、path、HTTPonly、secure、samesite\r\n    2. localhost:3000 与 localhost:5000 的 cookie 信息是否共享：这个和domain、path字段有关，如果这俩个字段相同就共享\r\n    3. secure设置后，不安全的站点无法修改cookie，且发送请求的时候不会将cookie发送给服务端\r\n    4. httponly设置后，浏览器无法访问此类cookie，该cookie只用于服务器\r\n    5. samesite\r\n        1. strict：完全禁止跨站点请求携带cookie\r\n        2. lax：链接（href）、预加载（preload）、GET表单可以携带cookie，其他不允许\r\n        3. None\r\n8.  get和post区别\r\n    1. 浏览器回退，GET无影响，POST会再次请求\r\n    2. GET产生的URL地址可以收藏、转发，POST不可以\r\n    3. GET请求会被浏览器主动缓存，POST需要手动设置\r\n    4. GET请求只能进行URL编码，POST支持多种编码方式\r\n    5. GET请求参数随URL被记录到浏览器中，POST不可以\r\n    6. GET请求参数有长度限制，POST没有\r\n    7. GET请求参数直接暴露在URL上不安全，不适合防止敏感信息，POST是放在RequestBody中\r\n9.  ws原理\r\n10. http status code（https://zhuanlan.zhihu.com/p/603410395）\r\n\r\n# js\r\n\r\n1. V8垃圾回收机制（文章）\r\n2. 作用域与闭包\r\n3. this和对象原型（文章）\r\n    1. 继承（文章）\r\n4. 类型与语法\r\n    1. 如何判断俩个浮点数相等\r\n\r\n        [Number.EPSILON](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number)\r\n        二进制向十进制转换时会丢失精度\r\n        ```js\r\n        equal = Math.abs(a + b - c) < Number.EPSILON\r\n        ```\r\n        https://juejin.cn/post/7210614375290863673\r\n\r\n5. amd、cjs、umd\r\n    \r\n    ```js\r\n    // umd\r\n    (function (root, factory) {\r\n      if (typeof define === 'function' && define.amd) {\r\n        define(['loadsh'], factory)\r\n      } else if (typeof exports === 'object') {\r\n        module.exports = factory(require('loadsh'))\r\n      } else {\r\n        root.returnExports = factory(root.loadsh)\r\n      }\r\n    })(this, function () { ... })\r\n    ```\r\n6. 异步与性能\r\n\r\n\r\n# vue（这里主要解释Vue3即可）\r\n\r\n1. vue3优化\r\n    1. 组合式API（Composition API）\r\n    2. monorepo\r\n    3. 响应式原理\r\n    4. TS\r\n    5. Tree-Shaking\r\n2. 响应式原理\r\n    1. Proxy/Reflect\r\n    2. watch/computed\r\n    3. method与computed区别\r\n    4. 如何代理Object、Array、Set、Map\r\n3. 渲染器\r\n    1. 虚拟DOM\r\n    2. Diff算法\r\n        1. 简单Diff\r\n        2. 双端Diff\r\n        3. 快速Diff\r\n4. 组件化\r\n    1. 组件生命周期\r\n    2. setup\r\n    3. 内置插件原理\r\n        1. keep-alive\r\n        2. teleport\r\n        3. suspense\r\n        4. Transition\r\n5. 编译器\r\n6. 其他原理\r\n    1. nextTick原理\r\n\r\n        更新响应式状态时，vue不会立即更新DOM，而是将它们缓存到一个队列中，在下一次tick中执行。nextTick是等待DOM刷新的方法。\r\n\r\n    2. provide/inject原理\r\n    3. Vue插件\r\n    4. Vue指令\r\n    5. 组合式函数原理（`<script setup>`语法糖做了什么）\r\n7. vue-loader原理：https://github.com/vuejs/vue-loader（没完全理解，后续继续）\r\n    1. vue-loader使用@vue/compiler-sfc解析SFC，生成不同语言的导入\r\n    2. 如果有js-loader，会添加到queries之前，如果有css-loader，会添加到queries之后\r\n    3. 当有扩展请求发起时，vue-loader会将它传递给匹配的loader\r\n    4. 使用Vue-template-compiler编译template；对于style scoped或module：\r\n        1. 在css-loader之前，style-loader之后需要后续处理\r\n8.  router原理\r\n    1. hash只能改变#后面的值，history可以随意设置同源url\r\n    2. hash只能添加字符串类数据，history可以通过API添加多种类型数据\r\n    3. hash不需要服务端配置，history需要服务端配置\r\n    4. hash通过location.hash跳转路由，通过hashchange event监听路由变化\r\n    5. history通过history.pushState()跳转路由，通过popstate event 监听路由变化（但是无法监听history.pushState())\r\n9. 性能优化\r\n \r\n# TS\r\n\r\n1. 相关API\r\n2. TS原理与实现\r\n    1. 枚举实现（js实现）\r\n        ```js\r\n        let enumObj\r\n        (function (obj) {\r\n          obj['apple'] = 'apple'\r\n        })(enumObj || enumObj = {})\r\n        ```\r\n\r\n# 工程化\r\n\r\n1. webpack（https://www.webpackjs.com/concepts/）\r\n    1. 简单介绍webpack\r\n    2. webpack优化项目\r\n        1. terse、uglify、swc压缩js\r\n        2. gzip、brotli传输压缩\r\n        3. 分析打包体积，替换更小体积的库\r\n        4. 使用支持Tree-shaking的库\r\n        5. 对无法tree-shaking的库进行按需引入\r\n        6. 合理使用browserlist，减少polyfill体积\r\n        7. coded-spliting，按路由加载包（优化性能）\r\n        8. 使用 webpack 的 splitChunksPlugin，把运行时、被引用多次的库进行分包，在分包时要注意避免某一个库被多次引用多次打包。此时分为多个chunk，虽不能把总体积变小，但可提高加载性能 (PS: 此条不减小总体积，但可提升加载性能)\r\n    3. loader原理\r\n        1. CSS Scoped | CSS Module\r\n\r\n            scoped内的CSS只作用于当前组件中的元素，但是子组件根元素会受到父组件影响（一般用于布局）。scoped组件如果想深层次影响子元素样式，需要::v-deep()。\r\n\r\n            - css specificity，scoped样式是类 + 属性选择器的一种，它的权重优先级高于类选择器，但是性能低于类选择器和ID选择器。\r\n            - 因为使用的类选择器字符是固定的，所有有可能被祖先节点同名类样式影响。\r\n            - 递归组件应该避免使用scoped，尤其是scoped内部包含后代选择器，性能损耗极大。可以将样式抽出，进而避免内存损耗\r\n\r\n            vue-style-loader css-loader modules: true打开，然后可以替代scoped方案：\r\n\r\n            1. module可以像JS对象一样使用，甚至可以传递给子组件\r\n            2. 最后生成的是类选择器，类名随机，与scoped的类属性选择器不同\r\n    4. webpack HMR原理\r\n2. vite\r\n    1. rollup及vite简介\r\n    2. 插件原理\r\n3. tree-shaking原理\r\n    1. 基于ESM进行静态分析，通过AST将未引用的代码移除，减少打包体积\r\n    2. webpack会先标记未使用的代码，然后再UglifyJSPlugin中删除代码\r\n4. npm包\r\n    1. 本地如何发包\r\n5. 仓库管理\r\n    1. monorepo + lerna\r\n6. docker\r\n7. git\r\n    1. action\r\n    2. hook\r\n8. vite、webpack是如何实现css-module的（为什么可以通过ESM导入的方式导入CSS文件）\r\n9. ts-loader做了哪些事情\r\n\r\n# election\r\n    1. v8\r\n# nest + typeorm\r\n# python + django\r\n\r\n# 项目问题\r\n\r\n1. 自研图形引擎Design Graph\r\n    \r\n    Mdesign3使用的MXGraph自定义图形难维护、图形扩展难度大性能低、框架体积大、不方便跨平台与复用。\r\n\r\n    graph是独立的组件，以支持跨平台和跨项目。组件内支持响应式，向外导出graph类。图形扩展通过插槽实现。\r\n\r\n    缺点：只是ui组件，不能进行业务，导致需要在组件和Node维护相同逻辑；性能不太好，尤其是多层级图形组件；\r\n\r\n    项目间缺点：组件由多个项目使用，但是维护仅有MDesign工具组。导致其他组使用组件难度大\r\n\r\n2. node层\r\n\r\n    扩大事务概念为步骤。ui层请求node会进入事务然后产生步骤id，然后传递给后端，后端会返回模型变更数据，node层再处理，如果数据发生变更，会将步骤保存。以支持前进后退。步骤id用于保持数据一致性。\r\n\r\n    删除通过修改isDelete字段实现\r\n\r\n    更新相当于拷贝原来数据、然后删除、然后新增。\r\n\r\n    分段处理数据，需要保存事务状态。然后修改事务中数据的变更。\r\n\r\n3. 技术缺点\r\n    \r\n    node层很多余，且前端没有对node进行分层，而是前后端都写。大部分人对ui层更熟悉，node代码很混乱。因为是核心工具，其他项目组成员有时也会来上手代码进行对应项目交接。\r\n\r\n    前后端是链式请求的，node层积累大量中间接口。因为业务的特殊性，Node层和后端是单线程的。\r\n\r\n4. 为什么M-Design项目中没有使用状态管理工具\r\n\r\n    1. 当时vue3生态不是很完善（比如element-plus有很多问题）\r\n    2. Action这种设计在后续开发中有点无心插柳的意思。\r\n\r\n        1. Action的设计与VueX、Pinia很相似\r\n        2. 比如本机多用户登录，直接实例化一个新的ActionManger即可。如果是使用状态管理工具，需要更高的成本。\r\n        3. 类扩展与开发相对方便，Action依赖class的Extends易于扩展，代码要比状态管理工具简介。\r\n\r\n5. 术语库设计（先了解i18n插件）\r\n\r\n    需求：统一各个项目产品文案、包括各类专业术语、文案话术、时间日期数字格式\r\n    \r\n    第一版：i18n，单个项目内\r\n\r\n    第二版：抽离为组件库，封装了i18n，约束时间日期数字格式。一套公共术语、话术。每个项目单独维护一个json用于特殊文案。\r\n\r\n    缺点：\r\n    后端返回的内容由语句变为术语，不利于开发。\r\n    \r\n\r\n\r\n6. 项目问题\r\n    1. 产品人员离职太频繁，导致开发、测试占主导地位。研发没有自我意识，更倾向于甲方定制，非常被动\r\n    2. 职能不明确，除了开发、测试能直接干扰需求，领导层也能干扰需求并调用研发人员。需求评审只有一个阶段\r\n    3. 有些项目没有项目经理，各项目之间沟通困难\r\n    4. 缺少技术共享，生态迟迟无法建立\r\n\r\n\r\n5. 有什么想问面试官的\r\n\r\n    1. 现有项目开发中，前端有架构师介入吗？\r\n    2. 产品研发的流程\r\n    3. 开发团队中有技术分享吗？\r\n    4. 对我今后学习方向有什么建议？\r\n\r\n> ### 面试中如果遇到问题，回来后及时做总结，然后得出详细思路\r\n"}},"D":["状态管理工具"]}