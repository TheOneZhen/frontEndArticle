随着应用技术升级，前端监控变得尤为重要。本篇将从前端监控内容入手，去了解前端监控的各项细节。
<!-- > 不局限与浏览器端的性能监测，还提供nodejs以及其他框架的一些监测或原理 -->

# 监控内容

## 错误捕获
### 语法错误

语法错误`SyntaxError`无法被`try-catch`捕捉，所以该类错误应该尽可能在开发阶段避免，在打包阶段进一步筛选问题，以防发布到生产环境。

### 同步错误

同步错误可以被`try-catch`捕捉，包括：指向错误`ReferenceError`、类型错误`TypeError`等。代码示例（浏览器与nodejs同）：

```js
try {
    const aaa = 'hello world!'
    console.log(aa)
} catch (e) {
    console.error(e) // ReferenceError: aa is not defined
}
```

### 异步错误

异步任务无法被`try-catch`捕捉，比如浏览器环境下`setTimeout`、`setInterval`以及`fetch`等API，这些任务会被存储起来，需要订阅错误消息才能**被捕捉**。

1. 浏览器环境下使用[`window.onError`](https://developer.mozilla.org/en-US/docs/Web/API/Window/error_event)

    ```js
        window.onerror = (event, source, lineno, colno, error) => {
            console.log(`
                可读的错误信息描述${event}
                错误脚本的URL字符串${source}
                发生错误的行${lineno}
                发生错误的列${colno}
                抛出的错误${error}
            `)
        }
    ```

    这个API不能捕获`Promise`错误。

2. nodejs环境可以通过监听[`uncaughtException`](https://nodejs.org/api/process.html#event-uncaughtexception)事件捕获错误：

    ```js
    try {
        setTimeout(() => {
            throw new Error('这是一个错误')
        })
    } catch (e) {
        console.error(e.message)
    }

    process.on('uncaughtException', e => {
        console.error('uncaught Exception:', e.message)
    })
    ```

    `uncaughtException`可以捕获整个node进程中未捕获的错误信息，但是nodejs环境区别于浏览器环境，当一段代码抛出错误后意味着丢失上下文。比如客户端请求错误，虽然被`uncaughtException`捕获，但此时不会再返回信息给客户端，客户端只能在请求超时时才能获取`no data received`错误。再者，`uncaughtException`会导致nodejs不能正常进行内存回收，引发内存泄露（[Warning: Using 'uncaughtException' correctly](https://nodejs.org/api/process.html#warning-using-uncaughtexception-correctly)）。

    这里不再细致介绍，这里给出俩个解决参考：

    1. [nodejs 错误异常的捕获](https://juejin.cn/post/7249991926307799077?searchId=2024080601505292470F027DFB8203A315)：这篇文章最后采用多进程 + `domain` + `uncaughtException`的方案，但是注意`domain`模块可能随时被移除。
    2. [nest decorator @catch()](https://github.com/nestjs/nest/blob/master/packages/common/decorators/core/catch.decorator.ts)

### Promise错误

nodejs环境可以通过上面介绍的方式捕获`Promise`错误，浏览器环境可以通过[`unhandledrejection`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unhandledrejection_event)事件监听。

### 资源加载错误

这个仅发生在浏览器环境，会导致页面无法正常展示。可以使用`window.addEventListener('error', () => {})`捕获，和上面介绍的`window.onerror`有一些差异，表现在：

1. `window.onerror`是一个全局变量，默认值为null。`window.onerror`拥有更多的参数，可以细致到源码行列数，`window.addEventListener`只有错误信息；
2. `window.addEventListener`比`window.onerror`先触发，且`window.addEventListener`可以监听资源加载的错误（监听DOM错误）；
3. 俩者捕获到错误时，都代表错误代码的下文（下一行）无法继续执行。

`window.addEventListener`代码示例：

```js
window.addEventListener("error", (event) => {  
    if (event.target instanceof HTMLImageElement || event.target instanceof HTMLScriptElement || event.target instanceof HTMLLinkElement) {
        console.error("资源加载错误:", event.target.src || event.target.href)
    }
});
```

### 流行框架的错误捕获

市面上流行的框架普遍无法通过宿主环境提供的错误捕获机制捕获常规错误，这个时候可以采用框架自身的错误机制进行错误的捕获。

> 框架相关错误以官网为准，这里不再示例，仅提供链接

1. Vue框架使用[`app.config.errorHandle`](https://vuejs.org/api/application.html#app-config-errorhandler)

    > 上面链接是Vue3版本，Vue2版本[Vue.config.errorHandle](https://v2.vuejs.org/v2/api/#errorHandler)

2. React框架在React16之后提供了[`ErrorBoundary`](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)组件，`render`函数报错时会触发距离当前组件最近的`ErrorBoundary`。
3. Nest带有内置异常层[Exception filters](https://docs.nestjs.com/exception-filters)，可以处理程序中未处理的异常。

## 性能&用户体验

### 浏览器环境

浏览器环境下主要使用[`performance`](https://developer.mozilla.org/en-US/docs/Web/API/Performance)API监测页面性能。

<img src="https://mdn.github.io/shared-assets/images/diagrams/api/performance/timestamp-diagram.svg" alt="performance navigation timing" />

上面这张图来自[MDN performance navigation timing](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming)，主线介绍了浏览器加载页面需要执行的过程，辅助线代表performance timing。旧标准中可以使用[`performance.timing`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/timing)。`performance navigation timing`API如下（新标准，与`performance.timing有差异`）：

| 时间                       | 作用                                                                                                           |
| -------------------------- | -------------------------------------------------------------------------------------------------------------- |
<!-- | navigationStart            | （可以理解为该页面的起始时间）同一个浏览器上下文的上一个文档卸载结束时的时间戳，如果没有上一个文档，这个值会和 |
| fetchStart                 | 相同unloadEventStartunload 事件抛出时的时间戳,如果没有上一个文档，这个值会是 0                                 |
| unloadEventEndunload       | 事件处理完成的时间戳,如果没有上一个文档，这个值会是 0                                                          | -->

| startTime | 


<!-- | redirectStart              | 第一个 HTTP 重定向开始时的时间戳，没有重定向或者重定向中的不同源，这个值会是 0                                 | -->
<!-- | redirectEnd                | 最后一个 HTTP 重定向开始时的时间戳，没有重定向或者重定向中的不同源，这个值会是 0                               | -->
<!-- | workerStart |  | -->
<!-- | fetchStart                 | 浏览器准备好使用 HTTP 请求来获取文档的时间戳。发送在检查缓存之前                                               | -->
<!-- | domainLookupStart          | 域名查询开始的时间戳，如果使用了持续连接或者缓存，则与 fetchStart 一致                                         |
| domainLookupEnd            | 域名查询结束的时间戳，如果使用了持续连接或者缓存，则与 fetchStart 一致                                         | -->
<!-- | connectStart |  | -->
| connectStartHTTP           | 请求开始向服务器发送时的时间戳，如果使用了持续连接，则与 fetchStart 一致                                       |
<!-- | secureConnectionStart      | 浏览器与服务器开始安全连接握手时的时间戳，如果当前网页不需要安全连接，这个值会是 0                             | -->
<!-- | connectEnd                 | 浏览器与服务器之间连接建立（所有握手和认证过程全部结束）的时间戳，如果使用了持续连接，则与 fetchStart 一致     | -->
<!-- | requestStart               | 浏览器向服务器发出 HTTP 请求的时间戳                                                                           | -->
<!-- | firstInterimResponseStart |  | -->
<!-- | responseStart              | 浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳                                                     | -->
<!-- unloadEventStart -->
<!-- unloadEventEnd -->
<!-- | responseEnd                | 浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前 HTTP 连接已经关闭，则返回关闭时）的时间戳   | -->

| domLoading                 | 当前网页 DOM 结构开始解析时的时间戳                                                                            |
<!-- | domInteractive             | 当前网页 DOM 结构解析完成，开始加载内嵌资源时的时间戳                                                          | -->
<!-- | domContentLoadedEventStart | 需要被执行的脚本已经被解析的时间戳                                                                             | -->
<!-- | domContentLoadedEventEnd   | 需要立即执行的脚本已经被执行的时间戳                                                                           | -->
<!-- | domComplete                | 当前文档解析完成的时间戳                                                                                       | -->
| loadEventStart         | 事件被发送时的时间戳，如果这个事件还未被发送，它的值将会是 0                                                   |
| loadEventEnd           | 事件结束时的时间戳，如果这个事件还未被发送，它的值将会是 0                                                     |

这里参考lighthouse的性能指标：

1. 首次内容绘制（First Contentful Paint，FP）：浏览器首次绘制来自 DOM 的内容的时间，内容必须是文本、图片（包含背景图）、非白色的 canvas 或 SVG，也包括带有正在加载中的 Web 字体的文本。 这是用户第一次开始看到页面内容，但仅仅有内容，并不意味着它是有用的内容（例如 Header、导航栏等），时间越小越好。
2. 可交互状态时间点（Time to Interactive，TTI）：此时浏览器可持续性接收用户操作。
3. 速度指数（Speed Index，SI）：可视区域内内容显示的平均时间。
4. 总阻塞时间（Total Block Time，TB）：第一次内容绘制（FCP）到可交互状态（TTI）时的时间。
5. 最大内容绘制（Largest Contentful Paint，LCP）：可视区域内最大的内容元素呈现到屏幕上的时间。
6. 累计布局偏移（Cumulative Layout Shift，CLS）：在应用达到可交互状态时（TTI），所有元素发生的偏移量。

> 除了上述指标，不同应用可能有独特的指标，没有固定要求。
### nodejs或js无渲染代码

1. 
2. 

## 用户行为&业务相关数据

1. 内容点击量
2. 页面用户浏览量
3. 页面停留时间

# 监控方式