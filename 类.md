原型
	js中每个对象都有一个[[Prototype]]特性，访问对象属性或方法时，首先检索当前对象，如果没有，再检索当前对象的[[Prototype]]，如果还没有会沿着[[Prototype]]继续向上检索，直至null为止。如果找到了，返回属性或方法，没找到返回undefined
		沿着[[Prototype]]不断向上，即原型链，js对象继承的核心
		通过这种机制，对象可以从其它对象继承属性和方法
	prototype与__proto__
		俩者本质没有区别，但是prototype是ES标准，__proto__是浏览器厂商的杰作
			ES6将__proto__纳入规范
		可以通过obj.__proto__去修改对象的原型链，但是会存在很多问题
			原型的修改开销极大，因为需要修改所有继承来自该[[Prototype]]的对象
			会导致原型链的污染
			__proto__显示在浏览器控制台中，实际是浏览器渲染出来的假节点，真正__proto__是get和set结合
		推荐使用Object.getPrototypeOf/Reflect.getPrototypeOf和Object.setPrototypeOf/Reflect.setPrototypeOf取代__proto__
			构造对象时，原型链会默认绑定构造函数对象
			可以通过Object.create()显示的绑定原型对象（功能同Object.setPrototypeOf/Reflect.setPrototypeOf，但是可以性能好）



类
	ES6新引入
	类内部所有方法都是不可枚举的
	继承
		原型链继承
			function parent() {
  this.name = 1
}
parent.prototype.getName = function () {
  return this.name
}
function child() {}
child.prototype = new parent()
let child1 = new child()
			优点：父构造方法的方法只需要创建一次
			缺点：1、实例会继承所有引用属性；2、创建实例时不能向parent传参
		通过构造函数继承（经典继承）
			function parent() {
  this.name = [1,2]
}
function child() {
  parent.call(this)
}
let child1 = new child()
let child2 = new child()
child.name.push(3)
console.log(child1.name) // [1, 2, 3]
console.log(child2.name) // [1, 2]
			优点：1、子实例避免了属性共享；2、child实例化时可以向parent传参
			缺点：方法在构造函数中定义，每次子实例化都需要创建一次方法
		组合继承（原型链 + 构造函数）
			function Parent (name) {
    this.name = name
    this.colors = ['red', 'blue', 'green']
}
Parent.prototype.getName = function () {
    console.log(this.name)
}
function Child (name, age) {
    Parent.call(this, name) // 1
    this.age = age
}
Child.prototype = new Parent() // 2
Child.prototype.constructor = Child
var child1 = new Child('kevin', '18')
			优点：1、子实例避免了属性共享；2、child实例化时可以向parent传参
			缺点：实例化过程中调用了2次父构造函数
		原型式继承
			function createObj(constructor) {
  function F() {}
  F.prototype = constructor
  return new F()
}
			优点：1、可以传参数（示例中没有体现出来）；2、父构造方法只调用一次
			缺点：引用类型属性会共享
		寄生式继承
			function createObj(constructor)  {
  let clone = Object.create(constructor)
  clone.sayName = function() {
    console.log("run here")
  }
  return clone
}
			优点：1、可以传参；2、引用类型属性不会共享
			缺点：方法在构造函数中定义，每次子实例化都需要创建一次方法
		寄生组合式继承
			function parent() {
  this.name = 1
  this.colors = ['blue', 'red']
}
parent.prototype.sayName = function() {
  console.log(this.name)
}
function child() {
  parent.call(this)
  this.age = 2
}
let F = function () {}
F.prototype = parent.prototype
child.prototype = new F()
			优点：1、可以传参；2、父构造函数的方法只需要创建一次；3、引用类型属性不会共享；4、子实例化过程中只调用父构造函数一次
	ES5实现
		constructor
			class Person {
    constructor(name) {
        this.name = name
    }
    say() {
        return this.name
    }
}
				function Person(name) {
    this.name = name
}
Object.defineProperty(Person1.prototype, 'say', {
    enumerable: false,
    writable: true,
    get () {
        return this.name
    }
})
		静态方法
			...
Person.staticFn = function() {}

new 操作符
	new一个构造函数，JE做了哪些事情
		创建一个临时对象{}
		给临时对象添加一个属性__proto__，并绑定构造函数的原型对象
		return临时对象或其它对象
			如果返回值是基本数据类型，继续返回this
			如果返回值是新对象，返回新对象
		给临时对象改名为prototype
		代码实现
			function objectFactory(Constructor, ...args) {

    var obj = new Object()

    obj.__proto__ = Constructor.prototype

    var ret = Constructor.apply(obj, args)

    return typeof ret === 'object' ? ret : obj

};
				function con(name) {
    this.name = name
}
objectFactory(con, 'a') // con {name: 'a'}
				这部分代码实际运行有问题，之后请细究
				因为new是操作符（语法糖），这里其实实现的是Object.create()
	特征
		new会捕捉距离最近的函数
			new new a().b() == new ((new a()).b())

bind、call、apply
	bind
		bind方法会创建一个新的函数，bind()被调用时，新函数会指向bind中第一个参数，其余参数将作为新函数的参数，在调用时使用
		bind的实现，相当于在其内部包裹call/apply，多次bind相当于对第一次bind的再次包装
		实现
			Function.prototype.bind = function(context){
  self = this;  //保存this，即调用bind方法的目标函数
  return function(){
      return self.apply(context,arguments);
  };
};
				简单实现
			Function.prototype.bind = function(context) {
    const PartialArgs = Array.prototype.slice.call(arguments, 1)
    self = this
    return function () {
        const NewArgs = Array.prototype.slice.call(arguments)
        return self.apply(context, NewArgs.concat(PartialArgs))
    }
}
				考虑函数柯里化（偏函数）
			Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var aArgs = Array.prototype.slice.call(arguments, 1), 
        fToBind = this, 
        fNOP = function () {},
        fBound = function () {
          return fToBind.apply(
              this instanceof fNOP && oThis ? this : oThis || window,
              aArgs.concat(Array.prototype.slice.call(arguments))
          );
        };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
				构造函数考虑（涉及原型链，后续细究）
		其它
			文章参考
				https://segmentfault.com/a/1190000018270750
	call
		实现
			Function.prototype.call2 = function (context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }

    var result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
}
				.call是ES3特性，所以这里通过eval实现

this
	箭头函数的this
		this指向不会改变
	类中的this
		类this默认指向此类实例
			如何使类的this总是指向这个类的实例？（私有属性、方法的实现）
				class {
  constructor(){
    this.fn = this.fn.bind(this)
  }
  fn() {}
}
		如果类中存在构造函数，且构造函数返回的是新的类，则this会指向新类，如果返回的是类的实例或者基础数据类型，this都会指向类的实例
		类内部总是“use strict”模式，调用一个this值为undefined的方法会抛出错误
			这个错误不知道怎么抛出
	面试题
		function foo() {
    getName = function() { console.log (1) }
    return this
}
foo.getName = function() { console.log(2) }
foo.prototype.getName = function() { console.log(3) }
var getName = function() { console.log(4) }
function getName() { console.log(5) }
 
1. foo.getName() // 2
2. getName() // 4
3. foo().getName() // 1
4. getName() // 1
5. new foo.getName() // 2
6. new foo().getName() // 3
7. new new foo().getName() // 3
			1. 略
2. 函数式声明在变量式声明之前，log5会被覆盖
3. foo()执行后，foo内getName变量提升至全局
4. 受3影响
5. new会实例化距离其最近的函数
6. 实例化foo，会从其原型链上拉属性方法放到一个新对象上
7. 5、6结合
	this对bind、call、apply的思考
		这些函数执行过程中到底对this及其相关做了什么
			预计原型链相关