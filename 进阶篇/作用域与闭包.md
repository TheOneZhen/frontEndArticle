# 作用域与闭包
<!-- 规范中如何描述作用域的 -->
《你不知道的JS》书中介绍作用域时引出另外俩个名词**引擎（Engine）**和**编译器（Compiler）**，**引擎**这词或多或少让人迷惑，尤其是web开发人员。这里的**引擎**是JS调度程序，望区分。然后我们看下《你不知道的JS》对三者只能的描述：
- 引擎：负责JS编译与执行过程
- 编译器：负责语法分析，并将JS源码编译成引擎认识的代码
- 作用域：责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

## 引擎，编译器和作用域
引擎负责编译和执行JS程序；编译器处理所有的解析和代码生成；作用域收集并维护一张所有被声明的标识符列表并执行隔离（作用域是一种规则，来告诉引擎和编译器如何通过标识符找变量）。

```js
  var a = 2;
```
例如处理上述程序，首先编译器入场：
1. 将片段拆分为`var a;`和`a = 2;`俩个片段；
2. 去特定作用域集合查找`var a;`，找到了就忽略声明并继续前进，否则通过作用域声明一个新变量。该过程为LHS查询（Left-Hand-Side）；
3. 将`a = 2;`变成引擎可执行代码并传递给引擎。

接下来引擎入场：
1. 通过查找**作用域集合**判断是否有`a`这个元素，有则将`2`赋值给`a`，否则抛出`ReferenceError`。该过程为RHS查询（Right-Hand-Side）。
   
<!-- 上述并不能代表真是的浏览器结构，只能描述作用域在其间的作用，需要查询资料链接不同浏览器内部组成。 -->

## 什么是作用域
> 代码中声明的变量，运行时应该以特定的规则放置在某些位置上，这个规则就是作用域。

作用域分为**词法作用域（Lexical Scope，也称静态作用域）**和**动态作用域（Dynamic Scope）**，JS对应词法作用域。
但是单独的**词法作用域**在处理JS复杂场景时过于抽象，所以又细化出**函数作用域**和**块作用域**。但是在ES6之前，受限于`var`和编译器LHS查询，只有try-catch勉强算作块作用域。ES6之后let和const的加入，让块作用域正式入场。
## 词法作用域
## 函数作用域（Function Scope）与块作用域（Block Scope）
## 声明提升
## 作用域闭包



2. LHS和RHS
   1. 非严格模式下，LHS在**嵌套作用域**中没有找到会在**全局作用域**中创建一个同名新变量
   2. RHS在**嵌套作用域**没有找到会抛出`ReferenceError`，严格模式下LHS也会抛出
3. `ReferenceError` 是关于 *作用域* 解析失败的，而 `TypeError` 暗示着 *作用域* 解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。（ch1 line 272）
4. 词法作用域(lexical scoping)
   1. 词法作用域只负责**变量标识符**的查找，当遇到**属性标识符**时，由**对象属性访问规则**接管
   2. 欺骗词法作用域
      1. eval会修改调用它的词法作用域
      2. with作用域规则与现有作用域规则冲突，表现为没有完全隔离词法作用域，使得对象的属性在with所在作用域中像标识符
5. 函数表达式内部同函数一样，是单独的作用域，所以对于那道题理解就很清晰了！可以很好的隐藏标识符
  ```js
    var b = 1;
    (function b () {
      b = 2;
      console.log(b);
    })()
    // constructor b...
  ```
6. 词法作用域是静态的，也就是说在代码编译之后，一个作用域的向上查找链是固定的
  ```js
  function foo() {
    console.log( a );
  }

  function bar() {
    var a = 3;
    foo();
  }

  var a = 2;

  bar(); // 2
  ```
  > 这里引申`词法作用域`、`动态作用域`和`this`的区别

### 块作用域
1. ES6之前，`var`与LHS的结合会使未声明的标识符最终被声明到全局作用域下，导致了块作用域表现的不明显，但可通过`try-catch`模拟作用域
    ```js
    try { throw i } catch(i) {
      ...
    }
    i // undedfined 
    ```
2. ES6中`let`和`const`劫持了声明它们的作用域，并将自己附着在上面，从而实现块作用域，**不过依旧无法阻挡`var`**；
3. 函数参数使用单独作用域，区别于**函数体作用域**，所以**函数参数作用域**在没有找到变量声明时会向上查找；
    ```js
    const a = 10
    function fn (b = a + 1, c = b + 1) { // 函数参数作用域中的`a`使用的是函数所在作用域中的`a`，而不是函数体内部声明的`a`
      const a = 20
      console.log(b) // 11
      console.log(c) // 12
    }
4. ch2 line 455，垃圾回收这里不是很懂，闭包应该不会打包作用域中全部资源，这里是由于`document`导致的吗，还是我之前的理解有偏差？

### 提升(hoisting)
上述`编译器`描述了处理程序`var a = 2;`将程序分为`var a`和`a = 2`俩个片段，而第一个片段由`编译器`在编译阶段处理。
1. 提升是以作用域为单位，将`函数声明`和`变量声明`提升到作用域顶部，以达到优化的目的
2. `var声明`和`函数声明`在`函数作用域`和`try-catch`作用域中的提升是提升到当前作用域顶部；而在`块作用域`中是提升到非块作用域顶部，即使`ES6块作用域劫持`也无法拦住它，TMD，**所以应该避免在块作用域中声明`var`和函数**
3. 函数表达式不会被提升
  ```js
    foo();
    bar();
    
    var foo = function bar() { ... };
  ```
  上述函数表达式会被解释为：
  ```js
    var foo;

    foo(); // TypeError
    bar(); // ReferenceError

    foo = function() {
      var bar = ...self...
      // ...
    }
  ```
4. 函数声明会先于变量声明提升，后续声明会覆盖前一个同标识符声明

### 闭包(closure)
作用域在其父作用域外被调用，但拥有对父作用域的引用，这个引用被称为闭包
1. ch5 line 313，这里的模块没有看懂，意思是对象闭包？这里和commonJS以及ESM产生了关联
<!-- JE在执行js代码片段前都要通过编译器进行编译 -->
<!-- 作用域与编译器、引擎有交互，这里之后根据YDKJSYY补全 -->

这一篇内容有些多，涉及作用域、变量提升、闭包、柯里化以及偏函数，
作用域规定了查找变量的范围，js采用词法作用域（Lexical Scoping，静态作用域），即由当前执行的作用域一直向上查找，到全局作用域查找完全结束（此过程为作用域链），比如这段代码：
```js
var a = 1
function f1() {
  console.log(a)
}
function f2() {
  var a = 2
  console.log(f1())
}
f2()
```
```js
// 输出
1
```
执行f2的时候，f1执行时并没有在f2内部找a，而是在自己所在的环境向上找。
## [变量提升（Hoisting）](https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting)
JE执行代码之前，会扫描代码并将函数、变量的声明放入内存，使得可以在声明代码之前使用它们（非严格模式下），像下面这样：
```js
a = 10
console.log(a) // 10
var a
```
变量提升只能提升声明，不能提升赋值（初始化）：
```js
console.log(a) // undefined
a = 10
var a
```
### 为什么要变量提升
可以解决函数相互递归调用的问题（函数A调用函数B，但B未声明（缓存中找不到），此时引擎去找B声明（产生大量开销））
### 变量提升的坏处
影响代码可读性，
### 解决办法
先声明，再赋值使用
ES6介入
### 介入V8
- 生成抽象语法树
  - 词法分析
    - JE检测当前作用域下的所有变量和函数声明，并将这些声明添加到《词法环境》内存中
      - 对于变量声明（包括匿名函数和变量式声明函数），会为变量分配内存并初始化为undefined，赋值语句在生成机器码阶段真正执行代码的时候才进行
      - 对于函数声明，会在内存里创建函数对象，并且直接初始化（函数处理优先级高于变量，会更靠前）
    - 语法分析
  - 生成字节码
  - 生成机器码
    - 代码执行阶段（此时可以提前使用声明的变量，只不过值为undefined，函数可以直接调用）

# ES6
let、const是ES6新特性，用作声明时也会被提升，但是它们会形成暂时性死区（TDZ），在声明之前调用它们会报错
	let声明的变量如果没有赋初始值，在代码执行阶段会赋值为undefined
	const不赋初始值会报错

## 函数作用域
- 由此引申的函数执行步骤（存疑）：
	函数定义后（JE扫描后）：保存作用域链到函数特性[[Scopes]]
	函数执行后，先开始准备工作：创建函数执行上下文栈，相关函数变量入栈，复制函数[[Scopes]]特性创建作用域链
	开始函数执行：平平无奇的入栈出栈
	函数执行完成后：如果存在闭包，通过AST扫描闭包函数，打包闭包需要的资源，闭包函数入栈，原函数无效资源释放

# var、let、const区别

# 作用域链
- 静态作用域链（js设计）
  - 函数和块内的变量声明会在作用域（[[Scopes]]）内创建一个绑定（binding），其它地方对此绑定的引用的访问顺序
    - 与代码顺序强相关
  - 方便做静态分析（tsc、babel）
- 动态作用域链
  - 与执行顺序强相关

# 项目中将全部的var替换为let有什么风险，具体方案
1. 手动替换
2. Babel

# const定义的变量可以被修改吗，如何保证不可修改
1. Object.freeze()
2. TS as const

# 闭包
- 什么是闭包
  - 一个函数可以调另一个函数内的资源
- 闭包创建前后
  - 为了防止部分资源（引用型对象）缺少引用而被销毁，所以闭包之前会执行父函数资源的打包
    - 父作用域销毁不能影响子作用域，但是不销毁父作用域也不行，会造成严重的资源浪费，所以需要打包被调用的资源
    - JE会扫描函数内的标识符，把子作用域中引用的资源打包成Closure链（global链也会打包，俩者形成新函数的外部环境，以支持函数的运行），放到[[Scopes]]特性中
    - 对于eval，因为是动态内容，没法静态分析，所以打包时会打包整个作用域（eval + 闭包性能差的原因）
  - 打包后，JE销毁父函数中无效引用资源
- 资源如何打包
  - AST扫描，JE Lazy Parsing函数（闭包性能差的原因）
- 支持闭包的数据结构
  - [[Scopes]]
    - Closure
      - 存放子作用域引用的资源（闭包专属）
    - Global
      - 存放全局变量引用
  - 闭包类每次实例化都会生成一个单独的作用域，同源实例化变量之间的环境（数据）不会相互影响
  - 此结构为栈，因为闭包函数内部也存在无限调用
- 闭包保存在何处
  - 闭包生成前：存在于引用堆中
  - 闭包生成后：引用会入栈，闭包内新声明的资源会入堆，引用上下文资源的位置不变（堆）
- 闭包导致的内存泄露
  - 闭包函数调用的上下文资源没有使用且不及时释放
- 闭包实现私有函数和变量
> 私有函数：只能在类中被调用，无法在类外被调用
```js
const counter = (function () {
    let count = 0
    function change(val) {
        count += val
    }
    return {
        increment: function () {
            change(1)
        },
        decrement: function () {
            change(-1)
        },
        value: function() {
            return count
        }
    }
})()
```
## 闭包应用
- 柯里化
  - 柯里化复杂了函数执行，但是提高了函数的适用性
  - 实现
    ```js
        function curry (fn) {
            return function curried (...args) {
                if (args.length >= fn.length) {
                    return fn.apply(this, args);
                } else {
                    return function (...args2) {
                        return curried.apply(this, args.concat(args2))
                    }
                }
            }
        }
    ```
  - lodash实现
    ```js
    ```
- 偏函数
  - 函数在调用的时候，不用传入全部函数（部分参数细节被隐藏）
  - 实现
    ```js
    function list() {
        return Array.prototype.slice.call(arguments)
    }
    const mid = list(undefined, 10)
    mid() // [10]
    mid(1, 2, 3) // [10, 1, 2, 3]
    ```

## Q&A
- "use strict"是怎样限定变量调用的
- 面试题
  ```js
    var foo = 5
    function hoist() {
        console.log(foo) // function foo() {}
        foo = 3
        console.log(foo) // 3
        function foo() {}
    }
    hoist()
    console.log(foo) // 5
  ```
- 无论变量在哪里被调用，也无论它如何被调用，它的词法作用域都只由变量被声明时所处的位置决定
- 函数声明和函数表达式的区别及应用
   1. 函数表达式变量名不会暴露给表达式所在的作用域
   2. 函数表达式写法（注意，这俩种写法在作用域提升方面有很大的不同）
      ```js
        // 自执行
        (function test() {...})()
        (function test() {...}())()
        (function () {...}())()
        // 通过变量的方式声明函数
        const a = function test() {} // 函数表达式不会暴露给a所在的作用域，所以外部访问test会ReferenceError
      ```
- JS主线程或编译器是如何查找作用域的？
## 引用
1. https://juejin.cn/post/7210614375290863673
2. https://zhuanlan.zhihu.com/p/121558249
3. https://juejin.cn/post/6957913856488243237
4. https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md
5. https://towind.fun/2021/05/10/js-hoisting/
6. https://fangyinghang.com/let-in-js/