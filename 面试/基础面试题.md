# CSS

1. 如何实现一个元素的水平垂直居中
    1. son：absolute + transform(tanslate)
    2. container(flex) + son(margin: auto)
    3. container(grid) + son(margin: auto)
2. 响应式布局
    > 主轴和交叉轴都可能有多个

    1. Multicol（多列）
        1. column-count：列数
        2. *-gap：间隙
        3. *-rule：添加分割线
        4. break-inside：多列布局下内容盒子如何中断
    2. Flex Box（弹性盒）
        1. flex-direction\wrap\
        2. flex = grow shrink basis
        3. flex-basis在纵向排列时代表height，为最优选
    3. Grid
    4. align-content：分配**多行内容**交叉轴方向剩余空间
    5. justify-content：分配主轴方向剩余空间
    6. justify-items：设置容器内每个元素主轴方向的justify-self
    7. justify-self: 设置元素相对于其交叉轴的对齐方式
    8. align-items: 设置每个元素的align-self
    9. align-self：设置元素相对于其所在主轴对齐方式
    10. place-content = align-content justify-content
    11. place-items = align-items justify-items
3. 标准盒和怪异盒

    content-box'width = content
    border-box'width = border + padding + content

4. BFC
    
    BFC（区块格式化上下文，Block Formatting Context）相当于一个隔离的布局环境，不受外部影响（它不是特定标签拥有的，更像是一个特性）

    1. 创建： 浮动元素、悬浮元素、display: flex\inline-block\table-cell、overflow：hidden|auto|scroll
    2. 特性：
        1. BFC 是一个独立的容器，容器内子元素不会影响容器外的元素。反之亦如此。
        2. 盒子遵照一些规则有序排列
        3. 相邻盒子margin-top-bottom会发生重叠
        4. BFC包含浮动元素时（另一个BFC），浮动元素也会参与区域高度计算
    3. 作用
        1. 清除浮动（或使用clearfix）
        2. 外边距重叠（margin-top -bottom重叠）

5. CSS伪类和伪元素
    
    伪元素会在文档流生成新的元素，使用content属性可以设置内容

6. CSS样式优先级

    内联样式 > ID选择器 > 类选择器（类、属性选择器、伪类） > 类型选择器（标签、伪元素）
    ！importment会破坏CSS specificity

    :is :not :has伪类中使用的选择器也会参与权重

    :where中的选择器优先级为0

7. `+ ~`
    
    `+`: 匹配紧邻兄弟节点
    `~`: 匹配随后的所有节点

8. css实现暗黑效果
    
    filter: invert(1);
    transition: color 300ms, background-color: 300ms;

    通过JS控制CSS变量

9. 屏幕内容列数自动等分

    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));

10. CSS Scoped | CSS Module

    scoped内的CSS只作用于当前组件中的元素，但是子组件根元素会受到父组件影响（一般用于布局）。scoped组件如果想深层次影响子元素样式，需要::v-deep()。

    - css specificity，scoped样式是类 + 属性选择器的一种，它的权重优先级高于类选择器，但是性能低于类选择器和ID选择器。
    - 因为使用的类选择器字符是固定的，所有有可能被祖先节点同名类样式影响。
    - 递归组件应该避免使用scoped，尤其是scoped内部包含后代选择器，性能损耗极大。可以将样式抽出，进而避免内存损耗

    vue-style-loader css-loader modules: true打开，然后可以替代scoped方案：
    1. module可以像JS对象一样使用，甚至可以传递给子组件
    2. 最后生成的是类选择器，类名随机，与scoped的类属性选择器不同

11. 行级元素：a\img\picture\span\input\select\textarea\label
12. aspect-ratio：规定盒子首选纵横比
13. JS监听媒体查询：window.matchMedia()

# 浏览器

1. 从输入url到展示页面浏览器做了那些事情。
    1. 根据URL获取IP地址，可能是本地缓存，也可能是进行DNS查询
    2. TCP握手
    3. TLS协商（Transport Layer Security）
    4. 浏览器获取资源
        1. 如果本地存在缓存，判断缓存是否过期，如果没有过期，复用。如果过期执行Get请求获取资源。
        2. 如果本地不存在缓存，发送GET请求获取资源
    5. 如果资源是HTML。开始解析
        1. 解析之前进行一次预加载扫描
            1. 如果遇到preload资源，请求获取资源
            2. 如果遇到CSS、JS文件，请求获取资源
        2. 解析HTML生成DOM
            1. 如果遇到CSS文件，请求资源
            2. 如果遇到script文件
                1. 如果是defer，请求资源，并在HTML解析之后执行脚本
                2. 如果是async，请求资源，待资源下载完毕立即执行脚本
                3. 如果都没有，阻塞HTML解析，一直到脚本下载完毕并且执行完毕
        3. 解析完毕后开始构建CSSOM，如果有CSS文件没有下载完全会阻塞渲染
        4. DOM和CSSOM合并成render tree
            1. 布局：从Render Tree根节点开始，确定节点的大小和位置
            2. 绘制：将可见部分绘制到屏幕上
    6. 页面展示。
    
2. 什么是跨域，如何解决

    1. 服务器响应头添加：Access-Control-Allow-Origin: *
    2. 反向代理中配置目标域名（或资源路径）（服务器代理请求的资源）
    3. JSONP
        
        HTML src属性引用资源不会触发SOP（同源策略），

        ```js
        function jsonp(url, params, CB) {
          const script = document.createElement('script')
          script.src = `${url}?${stringify({ callback: "padding", ...params })}`
          window['padding'] = CB
          document.body.appendChild(script)
        }
3. preload与prefetch
    1. preload用于提前加载当前界面资源
        1. 浏览器在解析HTML的时候会识别此属性优先加载资源
    2. prefetch用于提前加载其他界面资源
4. 异步加载脚本async与defer
    https://html.spec.whatwg.org/images/asyncdefer.svg
    async在脚本下载完后，立即执行（可能会阻塞HTML解析）
    defer在异步下载脚本，并在HTML解析之后，DomContentLoaded之前执行

5. DomContentLoaded与load
    1. HTML解析完成后，DomContentLoaded事件触发
    2. 当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件
6. 如何取消请求的发送(******)
    1. XHR：XMLHttpRequest.abort()
    2. fetch: AbortController
    3. axios: cancelToken
7. 浏览器使用ESM
    1. Module默认defer
    2. Module是单独作用域，不会污染到全局（IIFE）
    3. Module是strict
8. window
    1. requestIdleCallback：在浏览器空闲的时候执行函数（一般用于低优先级的任务）
    2. requestAnimationFrame
    3. postmessage：进程间通信
    4. queuemicrotask
9. iframe（直接看你的微前端篇，最后抽时间整一篇文章出来）


# 计算机相关

1. TCP
    1. 三次握手
        1. 客户端发送SYN
        2. 服务端接收SYN，响应SYN-ACK
        3. 客户端发送SYN
    2. 四次挥手
        1. 客户端发送FIN
        2. 服务端接收FIN，响应ACK
        3. 服务端发送FIN
        4. 客户端收到后发送ACK
    3. 请求头
        1. keep-alive：可以在一个TCP连接上发送多个请求，减少TCP连接开销
2. 安全（这里总结的不是很详细）
    1. SOP
    2. CSP：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP
    3. CSRF攻击：恶意伪造请求。cookie的samesite
    4. HSTS策略：可以强制浏览器使用HTTPS进行通信，可以减少重定向造成的额外请求和会话劫持风险
3.  http缓存
    1.  cache-control
        1. cache-control请求头包含属性：max-age、no-cache、no-store 
        2. no-cache与no-store区别
            1. no-cache可以在客户端缓存资源，但是每次都必须请求服务器检查新鲜度，来决定是从服务器获取最新资源（200）还是从客户端读取缓存（304），即协商缓存
            2. no-store不使用任何缓存
    2. 强缓存：通过cache-control中max-age控制。不会向服务器发送请求
    3. 协商缓存：访问缓存前需要进行新鲜度校验（有些不清晰）
        1. 通过比对etag和if-none-match
        2. if-modifie-since和last-modified和对比
4.  http2：https://juejin.cn/post/6844903667569541133
    1. http/1.1缺点
        1. TCP连接数限制：对于同一个域名，浏览器只能创建几个TCP连接，所以一般是同一个域名创建几个子域名来增加TCP连接数
        2. 线头阻塞（Head Of Line Blocking）：每个TCP连接同时只能处理一个请求，如果当前请求响应阻塞，后续请求都会受阻。
        3. Header内容多且不会压缩，每次请求都需要携带
        4. 明文传输不安全
    2. http2优势
        1. 二进制分帧层（Binary Framing Layer）
            
            报文消息被划分为更小的数据帧
        
        2. 多路复用：http/1.1中的帧可以在一次TCP连接中组合成流发送，而不需要创建多个TCP发送
            
        3. 服务端推送（server push）：客户端还没有请求，服务端就把一些必要的内容推送过去：http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html
        4. Header压缩（HPACK）
        5. 应用层的重置连接：可以在不断开连接的前提下取消stream
        6. stream请求优先级
        7. 流量控制
5.  https = http + tls
    1. http缺点：http内容使用明文传输，在传输过程中被劫持后传输内容完全暴露。不能判断数据是否被篡改。
        1. 数据明文传输
        2. 缺乏消息完整性检测
    2. https使用对称加密和非对称加密（CA数字签名 + 数字证书用于证明密钥的真伪）
    3. TLS协商
        1. 客户端发送请求并携带密码组合、随机数1
        2. 服务端响应密码组合和CA证书、随机数2
        3. 客户端发送随机数3，密钥生成
        4. 双方互发FIN
    4. 每次https请求都需要生成密钥吗
        1. 不会，服务器会为每个浏览器生成sessionId，在TLS握手阶段传给浏览器，之后浏览器的请求自动带上sessionId
6. base64
    1. 字符构成：a-z、A-Z、0-9、+、/
7.  cookie访问范围
    1. 包含的属性domain、expire（max-age）、path、HTTPonly、secure、samesite
    2. localhost:3000 与 localhost:5000 的 cookie 信息是否共享：这个和domain、path字段有关，如果这俩个字段相同就共享
    3. secure设置后，不安全的站点无法修改cookie，且发送请求的时候不会将cookie发送给服务端
    4. httponly设置后，浏览器无法访问此类cookie，该cookie只用于服务器
    5. samesite
        1. strict：完全禁止跨站点请求携带cookie
        2. lax：链接（href）、预加载（preload）、GET表单可以携带cookie，其他不允许
        3. None
8.  get和post区别
    1. 浏览器回退，GET无影响，POST会再次请求
    2. GET产生的URL地址可以收藏、转发，POST不可以
    3. GET请求会被浏览器主动缓存，POST需要手动设置
    4. GET请求只能进行URL编码，POST支持多种编码方式
    5. GET请求参数随URL被记录到浏览器中，POST不可以
    6. GET请求参数有长度限制，POST没有
    7. GET请求参数直接暴露在URL上不安全，不适合防止敏感信息，POST是放在RequestBody中
9.  ws原理
10. http status code

# js

1. 如何判断俩个浮点数相等

    [Number.EPSILON](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number)
    二进制向十进制转换时会丢失精度
    ```js
    equal = Math.abs(a + b - c) < Number.EPSILON
    ```
    https://juejin.cn/post/7210614375290863673
2. V8垃圾回收机制（文章）
3. this和对象原型（文章）
    1. 继承（文章）
4. amd、cjs、umd
    
    ```js
    // umd
    (function (root, factory) {
      if (typeof define === 'function' && define.amd) {
        define(['loadsh'], factory)
      } else if (typeof exports === 'object') {
        module.exports = factory(require('loadsh'))
      } else {
        root.returnExports = factory(root.loadsh)
      }
    })(this, function () { ... })
    ```

# vue

1. vue3相对于vue2优势
    1. 组合式API（Composition API）
2. vue3生命周期
    1. 描述各生命周期钩子做了什么
    2. setup
        1. `<script setup>`语法糖做了什么
3. 响应式原理
4. 
5. vue-loader原理：https://github.com/vuejs/vue-loader（没完全理解，后续继续）
    1. vue-loader使用@vue/compiler-sfc解析SFC，生成不同语言的导入
    2. 如果有js-loader，会添加到queries之前，如果有css-loader，会添加到queries之后
    3. 当有扩展请求发起时，vue-loader会将它传递给匹配的loader
    4. 使用Vue-template-compiler编译template；对于style scoped或module：
        1. 在css-loader之前，style-loader之后需要后续处理
6. nextTick原理

    更新响应式状态时，vue不会立即更新DOM，而是将它们缓存到一个队列中，在下一次tick中执行。nextTick是等待DOM刷新的方法。

7. router原理
    1. hash只能改变#后面的值，history可以随意设置同源url
    2. hash只能添加字符串类数据，history可以通过API添加多种类型数据
    3. hash不需要服务端配置，history需要服务端配置
    4. hash通过location.hash跳转路由，通过hashchange event监听路由变化
    5. history通过history.pushState()跳转路由，通过popstate event 监听路由变化（但是无法监听history.pushState())

8. vue响应式原理及实现
9.  内置组件原理
    1. keep-alive
    2. teleport
    3. suspense

# TS

1. 相关API实现
    1. 枚举实现（js实现）
        ```js
        let enumObj
        (function (obj) {
          obj['apple'] = 'apple'
        })(enumObj || enumObj = {})
        ```
2. TS原理

# 工程化

1. webpack（https://www.webpackjs.com/concepts/）
    1. entry：
    2. output
    3. loader
    4. plugin
    5. mode
    6. 浏览器兼容性
    7. 环境
2. webpack优化项目
    1. terse、uglify、swc压缩js
    2. gzip、brotli传输压缩
    3. 分析打包体积，替换更小体积的库
    4. 使用支持Tree-shaking的库
    5. 对无法tree-shaking的库进行按需引入
    6. 合理使用browserlist，减少polyfill体积
    7. coded-spliting，按路由加载包（优化性能）
    8. 使用 webpack 的 splitChunksPlugin，把运行时、被引用多次的库进行分包，在分包时要注意避免某一个库被多次引用多次打包。此时分为多个chunk，虽不能把总体积变小，但可提高加载性能 (PS: 此条不减小总体积，但可提升加载性能)
3. webpack HMR原理
4. tree-shaking原理
    1. 基于ESM进行静态分析，通过AST将未引用的代码移除，减少打包体积
    2. webpack会先标记未使用的代码，然后再UglifyJSPlugin中删除代码
5. webpack runtime
6. npm包
    1. 本地如何发包
7. 仓库管理
    1. monorepo