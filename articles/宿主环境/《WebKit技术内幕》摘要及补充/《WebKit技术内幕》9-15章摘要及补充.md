《WebKit技术内幕》是我在知乎上**得到**的一本书，出发点源于自己的学习方向——前端跨端，一如Electron、Flutter这类框架。个人感觉这本书适合具有一定前端开发经验的读者，或者从事更底层开发（浏览器项目开发）的人阅读。同时此书中虽然列举了很多实践，但是明显与版本脱钩（书籍出版年限2014年），如果你有相关项目代码辅助阅读更好。然后我是在微信读书APP上购买了此书，链接[https://weread.qq.com/web/bookDetail/4b332350813ab7c27g013503](https://weread.qq.com/web/bookDetail/4b332350813ab7c27g013503)。

> 本篇（系列）文章只是对原文章作总结，有些内容虽然是直接摘抄下来的，但是不代表具备权威性（有些内容老旧），请读者斟酌。
>
> 本篇（系列）文章相较于原文忽略了很多内容，比如实践（代码）、前端开发基础内容等，建议读者将本文做为二手阅读。

# 第九章 JavaScript引擎

## 9.1 概述

JS是动态类型、**解释型**语言（这种概况不太准确，比如在V8的实现更偏向于编译型语言），一般作为脚本运行在WEB环境。对于C++这种强类型编译型语言，在属性访问时，C++依据对象地址以及初始size字节便可访问对象属性，而JS则类似需要通过字符串匹配才能访问属性，存在巨大性能差异。为了弥补性能问题，JS引擎的诸多实践中引入了JIT技术（Just In Time），该技术会将JS直接编译为本地代码（机器码），大幅度提升性能。

JS引擎包括以下几个部分：

- 编译器：将源代码编译成抽象语法树；
- 解释器：接受字节码然后解释执行，依赖垃圾回收机制；
- JIT工具：将字节码或抽象语法树转换为机器码；
- 垃圾回收器和分析工具（Profiler）：负责垃圾回收和收集引擎中的信息，帮助改善引擎的性能和功效。

<img src="https://res.weread.qq.com/wrepub/CB_3300055433_255_1.jpg" alt="JavaScript代码的编译和执行过程" />

## 9.2 V8引擎

### 9.2.2 工作原理

V8中数据的表示分为俩部分：

- 数据实际内容：长度不固定，且内容类型不同，比如`String`、`Object`等；
- 数据句柄（handle）：包含指向数据的指针，除了极少数的数据类型比如`int`、`bool`类型存储在句柄中，其他类型都存储在堆中（因为长度不固定）。

V8首先使用解释器将**源代码**转变成**抽象语法树**，通过JIT编译器的全代码生成器(full code generator)从抽象语法树直接生成本地代码（机器码），所以没有像Java一样的虚拟机或者字节码解释器，这样做可以减少抽象语法树到字节码的转换时间。但是也存在一些缺点：

- 一些场景没有必要将JS转换为本地代码（机器码）
- 缺少源码到本地代码（机器码）的中间态，不同OS移植性维护成本高，比如Java在抽象语法树之后会编译成字节码以支持不同OS移植，然后使用解释器转换为本地代码（机器码）。

为了使JS能够在不同的操作系统运行，且本地代码（机器码）跟具体的硬件平台密切相关，V8使用了多个后端来生成对应的代码。虽然JIT技术太幅度提升了JS的性能，但是缺少中间表示层（字节码），导致性能没法进一步优化，V8在后续又做了很多大的变动：

- 延迟（deferred）：很多JavaScript代码的编译直到运行的时候被调用到才会发生，这样可以减少时间开销；
- 引入Crankshaft编译器

    Crankshaft编译器主要针对那些热点函数进行优化。该编译器基于JavaScript源代码开始分析，而不是本地代码（机器码）。

- 优化回滚（Deoptimization）

    Crankshaft编译器在优化时会优先假定变量类型不会变动，然后生成高效的本地代码（机器码）。如果变量类型中途发生改变，它会回滚到代码优化前的一般情况，这个过程会更低效。

- 隐藏类（Hidden Class）和内嵌缓存（Inline Cache）

    V8使用类和偏移位置思想，将本来需要通过字符串匹配来查找属性值的算法改进为使用类似C++编译器的偏移位置的机制来实现，这就是隐藏类。
    
    隐藏类之上还可以使用缓存来避免重复查询，也就是将之前查找的隐藏类和偏移值保存下来。当下次查找的时候，首先比较当前对象是否也是之前的隐藏类，如果是的话，可以直接使用之前缓存的偏移值，从而减少查找表的时间，即内嵌缓存。

V8管理分为俩部分：

- 内存分配

    

- 垃圾回收机制