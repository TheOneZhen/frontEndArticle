# Vue3

## Vue3相较于Vue2的改变

### 代码层面
1. 采用monorepo管理源码，根据功能将不同的模块拆分到packages目录下的不同子目录，使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，提高了代码的可维护性。
2. TypeScript引入，利于IDE对变量类型的推导，在开发阶段避免一些易错问题

### 性能方面

#### 优化源码体积
1. 移除冷门功能
2. 引入tree-sharking，减少打包体积（https://segmentfault.com/a/1190000039359421）

3. 数据劫持改变
   Vue2中通过Object.defineProperty劫持数据的getter和setter，
   1. 必须指定拦截的key，所以不能拦截对象中属性的添加和删除（Vue2提供了$set和$delete方法）
   2. 对于深层数据有较大的性能负担


	响应式原理
		深层响应如何实现
		基于proxy的响应式局限性
			对基本数据类型无效，基本数据类型需要额外封装
			vue响应式系统通过属性访问进行追踪，地址改变时响应式链接会丢失（引用改变，结构赋值会使原响应式对象无效）
		ref与reactive
			对于此，vue为结构赋值提供了额外的方法
			ref会包装基础数据类型，对于对象则适用reactive包装
		问题记录
			watch加上deep描述之后可以监听到容器内元素的变化吗？
	组件基础
		DOM解析
			Vue模板解析器只支持部分标签的自闭（<tem />）解析，所以对于所有的自定义标签，闭合尽量采用<tem></tem>的方式闭合，不然会被解析器判定为标签未结束
		生命周期
			setup
				setup中可以直接await（第一个await会让组件成为异步依赖），还可以通过suspense或者生命周期钩子函数实现异步
				setup是一个composition API，在它内部可以调用各种生命周期钩子
		组合式与选项式
			选项式基于组合式开发而成，且选项式是一种语法糖
			<script setup>对应组合式
	深入组件
		组件注册
			全局注册
				全局注册的组件在子组件内不需要引入即可使用，但是对于未使用的全局组件，在生产打包时Tree-Shaking不会将其自动移除
				全局组测和全局变量一样，多了会导致项目后期维护复杂化
			局部注册
		props
			类型注解
				首字母大写的js默认类型与小写的有什么区别
		插槽（slot）
			问题总结
				如何判断slot中是否传入组件
					一般建议利用slot默认组件特性去判断
					如果是在父组件中进行监听，还是建议数据的监听，这样逻辑也会更通顺一些
		依赖注入（provide/inject）
		异步组件
	逻辑复用
		组合式函数（VUE3模块化最佳体现，也是组被叫做组合式的原因）
			函数应该是一个同步函数（或者异步不会破坏返回值的响应式），可以使VUE能够确定当前正在执行的是哪个组件，以致于：
3. 将声明周期钩子注册到该组件实例
4. 将计算属性和监听器注册到该组件实例，并在卸载时移除监，避免内存泄漏
			mixin缺点
				数据源不清晰
				命名空间冲突
				隐式的跨mixin交流
			和无渲染组件的对比
			和React Hooks的对比
		自定义指令
			相较于组合式函数对逻辑的复用，自定义指令侧重于对DOM操作逻辑的复用，而且更深入DOM的生命周期（指令钩子）
			在setup中，任何以v开头的驼峰式变量都可以被用作一个自定义指令（语法糖）。在选项式中，需要通过directives选项注册（注册不需要v）
			指令钩子
				created
				beforeMount
				mounted
					在绑定元素以及其全部子组件挂载之后
				beforeUpdate
				updated
				beforeUnmount
				unMounted
			钩子参数
				el
					指令绑定的元素（DOM）
				binding(v-directive: arg.modifiers = value)
					value
						传给指令的值（等于号后面），可以是表达式（表达式被传入后会自定执行，实际传进来的也是基础数据类型或引用类型）
					oldValue
						之前的值（只适用于更新）
					arg
						传递给指令的参数（可以基于参数的响应式做相应的改变，参考组合式函数中的unref）
					modifiers
						传过来的修饰符
					instance
						使用此指令的组件实例（component）
					dir
						指令的定义对象
				vnode
				prevNode
			问题记录
				指令内存泄漏风险（指令中监听事件卸载时机以及引用存储）
					在指令所在的module中维护一个记录指令事件的表结构
					通过元素的dataset attribute实现
				vue3支持多根节点，但指令应用到多根节点组件时会被忽略且抛出警告
					不推荐在封闭组件上使用自定义指令
					对封闭组件进行包装
			除了el外，其它参数都是只读的（或者不建议修改）
		插件
	内置组件
		transition
		teleport
			与vue2种portal的比较
	应用规模化
		单文件组件（SFC）
			使用SFC必须使用构建工具
			SFC的优势
				可以编写模块化的组件，使强相关的关注点内聚到一起
				预编译模版，避免运行时编译开销
				作用域CSS，防止污染
				在使用组合式API时语法更简单
				通过交叉分析模版和洛基代码能进行更多编译时优化
				开箱即用的模块热更新（HMR）支持
			SFC是如何工作的
				编译时，.vue文件交由@vue/compiler-sfc编译成js和css文件
				SFC编译后的js是一个标准的ES模块，可以在其他js文件中被导入
				SFC中的<style>在开发时会注入成原生的H5标签以支持热更新，生产环境下它们会被抽取成一个单独的css文件
			集成了SFC的编译工具
				vite
				vue-cli
				vue
		工具链（推荐在项目搭建初期时详细阅读，方便环境搭建）
		前端路由
			与服务端路由区别
				路由代表资源，服务端的路由对应前端的一些资源，比如一个html、css、js文件
				前端路由改变不会向后端发送资源请求
		服务端渲染（SSR）
			用户访问的时候，服务端动态打包静态资源给用户
			优点
				快，尤其是对重视首屏加载这类资源来说
				更好的SEO
			缺点
				需要更高的服务器负载
				开发与构建需要nodejs支持
				一些特定的生命周期钩子无效
			静态站点生成（SSG）
				预渲染，给所有用户的都是统一的静态资源（类似SPA的index）
				当数据变化时，需要重新生成页面
	最佳实践
	TS支持
	VUE3进阶
	provide、inject实现原理
	diff算法
	问题记录
		emit事件向上多层传递
		ts文件导出的defineComponent在开发环境可以正常使用，生产环境不能渲染
		defineComponent在组件中使用时是局部组件，局部组件的渲染受其所在组件影响




Vue2
	响应式原理
	生命周期
	portal
		源自于react
		实现方式
			router-view
			promise
			工具
				portal-vue
	export
	component
		name
	性能优化