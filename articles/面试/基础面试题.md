# CSS

1. 如何实现一个元素的水平垂直居中
    1. son：absolute + transform(tanslate)
    2. container(flex) + son(margin: auto)
    3. container(grid) + son(margin: auto)

2. 响应式布局
    > 主轴和交叉轴都可能有多个

    1. Multicol（多列）
        1. column-count：列数
        2. *-gap：间隙
        3. *-rule：添加分割线
        4. break-inside：多列布局下内容盒子如何中断
    2. Flex Box（弹性盒）
        1. flex-direction\wrap\
        2. flex = grow shrink basis
        3. flex-basis在纵向排列时代表height，为最优选
    3. Grid
        1. 1fr，一份
    4. align-content：分配**多行内容**交叉轴方向剩余空间
    5. justify-content：分配主轴方向剩余空间
    6. justify-items：设置容器内每个元素主轴方向的justify-self
    7. justify-self: 设置元素相对于其交叉轴的对齐方式
    8. align-items: 设置每个元素的align-self
    9.  align-self：设置元素相对于其所在主轴对齐方式
    10. place-content = align-content justify-content
    11. place-items = align-items justify-items
3. 标准盒和怪异盒

    content-box'width = content
    border-box'width = border + padding + content

4. FC（文档流，Formatting Context）

    页面中的一块渲染区域，有自己的渲染规则，决定其子元素如何布局以及和其他元素之间的关系和作用。

    1. BFC（区块格式化上下文，Block Formatting Context）（GFC、FFC也是一个BFC）
        
        块级盒子布局时，BFC为其提供隔离环境，使其不影响容器外布局，元素在这个环境中按照一定规则进行布局。

        1. 创建： 根元素、浮动元素、悬浮元素、display: flex\inline-block\table\grid、overflow：hidden|auto|scroll
        2. 特性：
            1. BFC 是一个独立的容器，容器内子元素不会影响容器外的元素。反之亦如此。
            2. 盒子遵照一些规则有序排列
            3. 相邻盒子margin-top-bottom会发生重叠
            4. BFC包含浮动元素时（另一个BFC），浮动元素也会参与区域高度计算
        3. 作用
            1. 清除浮动（或使用clearfix）：浮动元素会覆盖普通文档流，但是不会覆盖BFC
            2. 阻止margin-top\margin-bottom合并：外部元素不会影响BFC布局
            3. 阻止容器高度塌陷：浮动元素参与区域高度计算
    2. IFC（行级格式化上下文）

        行级元素包括：a\img\picture\span\input\select\textarea\label

        1. 创建：块级元素中仅包含行内元素
        2. 特性：
            1. 水平横向排列，垂直方向起点是父元素顶部
            2. 只计算横向样式（ml\mr\pl\pr\border），行高由CSS行高计算规则来确定
            3. 垂直方向可使用（vertical-align）进行布局
            4. 如果宽度小于容器宽度，由text-align决定水平分布，超出容器宽度可以会溢出，可以设置white-wrap换行。

5. CSS伪类和伪元素
    
    伪元素会在文档流生成新的元素，使用content属性可以设置内容

    伪类可以定义元素在不同状态下的样式，或者选择元素（比如：is ：not：has）。

6. CSS样式优先级

    内联样式 > ID选择器 > 类选择器（类、属性选择器、伪类） > 类型选择器（标签、伪元素）

    ！importment会破坏CSS specificity

7. aspect-ratio：规定盒子首选纵横比
8. animation偏向于主动，transition有点被动

# 浏览器

1. 从输入url到展示页面浏览器做了那些事情。
    1. 根据URL获取IP地址，可能是本地缓存，也可能是进行DNS查询
    2. TCP握手
    3. TLS协商（Transport Layer Security）
    4. 浏览器获取资源
        1. 如果本地存在缓存，判断缓存是否过期，如果没有过期，复用。如果过期发送Get请求获取资源。
        2. 如果本地不存在缓存，发送GET请求获取资源
    5. 如果资源是HTML。开始解析
        1. 解析之前进行一次预加载扫描
            1. 如果遇到preload资源，请求获取资源
            2. 如果遇到CSS、JS文件，请求获取资源
        2. 解析HTML生成DOM
            1. 如果遇到CSS文件，请求资源
            2. 如果遇到script文件
                1. 如果是defer，请求资源，并在HTML解析之后执行脚本
                2. 如果是async，请求资源，待资源下载完毕立即执行脚本
                3. 如果都没有，阻塞HTML解析，一直到脚本下载完毕并且执行完毕
        3. 触发domcontentLoaded事件
        4. 解析完毕后开始构建CSSOM
            1. 如果有CSS文件没有下载完全会阻塞渲染
            2. 如果CSS文件中包含@import，阻塞渲染，下载文件
        5. DOM和CSSOM合并成render tree
            1. 布局：从Render Tree根节点开始，确定节点的大小和位置
            2. 绘制：将可见部分绘制到屏幕上
            3. 合成：将文档中不同层按正确的顺序合并到一起
        6. 触发load事件
    6. 页面展示。
    
2. 什么是跨域，同源策略。如何解决

    跨域资源共享（CORS）

    1. 服务器响应头添加：Access-Control-Allow-Origin: *
    2. 反向代理中配置目标域名（或资源路径）（服务器代理请求的资源）
    3. JSONP
        
        HTML src属性引用资源不会触发SOP（同源策略），

        ```js
        function jsonp(url, params, CB) {
          const script = document.createElement('script')
          script.src = `${url}?${stringify({ callback: "padding", ...params })}`
          window['padding'] = CB
          document.body.appendChild(script)
        }
    4. 跨域存在的安全问题


3. preload与prefetch
    1. preload用于提前加载当前界面资源
        1. 浏览器在解析HTML的时候会识别此属性优先加载资源
    2. prefetch用于提前加载其他界面资源
4. 异步加载脚本async与defer
    https://html.spec.whatwg.org/images/asyncdefer.svg
    async在脚本下载完后，立即执行（可能会阻塞HTML解析）
    defer在异步下载脚本，并在HTML解析之后，DomContentLoaded之前执行

5. DomContentLoaded与load
    1. HTML解析完成后，DomContentLoaded事件触发
    2. 当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件
6. 如何取消请求的发送
    1. XHR：XMLHttpRequest.abort()
    2. fetch: AbortController
    3. axios: cancelToken
7. 浏览器使用ESM
    1. Module默认defer
    2. Module是单独作用域，不会污染到全局（IIFE）
    3. Module是strict
8. window
    1. requestIdleCallback：在浏览器空闲的时候执行函数（一般用于低优先级的任务）
    2. requestAnimationFrame：在浏览器下一次重绘之前调用指定函数更新动画
    3. postmessage：进程间通信
    4. queuemicrotask：微函数执行栈
    5. matchMedia
    6. getSelection
9. iframe（微前端篇）
10. 图形绘制
    1. svg
        1. 矢量图形、可以添加事件处理器、可以使用css、结合Vue相对简单
        2. 性能差，不适合渲染大量动态图形
    2. canvas
        1. 只能绘制栅格图形，不能绘制矢量图形、不支持事件处理器、缩放困难、动画需要手动实现
        2. 性能好（只考虑结果，不考虑过程）
11. 请求
    1. XMLHttpRequest
    2. fetch

# 计算机相关

1. TCP
    1. 三次握手
        1. 客户端发送SYN
        2. 服务端接收SYN，响应SYN-ACK
        3. 客户端发送SYN
    2. 四次挥手
        1. 客户端发送FIN
        2. 服务端接收FIN，响应ACK
        3. 服务端发送FIN
        4. 客户端收到后发送ACK
    3. 请求头
        1. keep-alive：可以在一个TCP连接上发送多个请求，减少TCP连接开销
2. 安全（这里总结的不是很详细）
    1. SOP
    2. CSP：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP
    3. CSRF攻击：恶意伪造请求。cookie的samesite
    4. HSTS策略：可以强制浏览器使用HTTPS进行通信，可以减少重定向造成的额外请求和会话劫持风险
3.  http缓存
    1.  cache-control
        1. cache-control请求头包含属性：max-age、no-cache、no-store 
        2. no-cache与no-store区别
            1. no-cache可以在客户端缓存资源，但是每次都必须请求服务器检查新鲜度，来决定是从服务器获取最新资源（200）还是从客户端读取缓存（304），即协商缓存
            2. no-store不使用任何缓存
    2. 强缓存：通过cache-control中max-age控制。不会向服务器发送请求
    3. 协商缓存：访问缓存前需要进行新鲜度校验（有些不清晰）
        1. 通过比对etag和if-none-match
        2. if-modifie-since和last-modified和对比
4.  http2：https://juejin.cn/post/6844903667569541133
    1. http/1.1缺点
        1. TCP连接数限制：对于同一个域名，浏览器只能创建几个TCP连接，所以一般是同一个域名创建几个子域名来增加TCP连接数
        2. 线头阻塞（Head Of Line Blocking）：每个TCP连接同时只能处理一个请求，如果当前请求响应阻塞，后续请求都会受阻。
        3. Header内容多且不会压缩，每次请求都需要携带
        4. 明文传输不安全
    2. http2优势
        1. 二进制分帧层（Binary Framing Layer）
            
            报文消息被划分为更小的数据帧
        
        2. 多路复用：http/1.1中的帧可以在一次TCP连接中组合成流发送，而不需要创建多个TCP发送
            
        3. 服务端推送（server push）：客户端还没有请求，服务端就把一些必要的内容推送过去：http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html
        4. Header压缩（HPACK）
        5. 应用层的重置连接：可以在不断开连接的前提下取消stream
        6. stream请求优先级
        7. 流量控制
5.  https = http + tls
    1. http缺点：http内容使用明文传输，在传输过程中被劫持后传输内容完全暴露。不能判断数据是否被篡改。
        1. 数据明文传输
        2. 缺乏消息完整性检测
    2. https使用对称加密和非对称加密（CA数字签名 + 数字证书用于证明密钥的真伪）
    3. TLS协商
        1. 客户端发送请求并携带密码组合、随机数1
        2. 服务端响应密码组合和CA证书、随机数2
        3. 客户端发送随机数3，密钥生成
        4. 双方互发FIN
    4. 每次https请求都需要生成密钥吗
        1. 不会，服务器会为每个浏览器生成sessionId，在TLS握手阶段传给浏览器，之后浏览器的请求自动带上sessionId
6. base64
    1. 字符构成：a-z、A-Z、0-9、+、/
7.  cookie访问范围
    1. 包含的属性domain、expire（max-age）、path、HTTPonly、secure、samesite
    2. localhost:3000 与 localhost:5000 的 cookie 信息是否共享：这个和domain、path字段有关，如果这俩个字段相同就共享
    3. secure设置后，不安全的站点无法修改cookie，且发送请求的时候不会将cookie发送给服务端
    4. httponly设置后，浏览器无法访问此类cookie，该cookie只用于服务器
    5. samesite
        1. strict：完全禁止跨站点请求携带cookie
        2. lax：链接（href）、预加载（preload）、GET表单可以携带cookie，其他不允许
        3. None
8.  get和post区别
    1. 浏览器回退，GET无影响，POST会再次请求
    2. GET产生的URL地址可以收藏、转发，POST不可以
    3. GET请求会被浏览器主动缓存，POST需要手动设置
    4. GET请求只能进行URL编码，POST支持多种编码方式
    5. GET请求参数随URL被记录到浏览器中，POST不可以
    6. GET请求参数有长度限制，POST没有
    7. GET请求参数直接暴露在URL上不安全，不适合防止敏感信息，POST是放在RequestBody中
9.  ws原理
10. http status code（https://zhuanlan.zhihu.com/p/603410395）

# js

1. V8垃圾回收机制（文章）
2. 作用域与闭包
3. this和对象原型（文章）
    1. 继承（文章）
4. 类型与语法
    1. 如何判断俩个浮点数相等

        [Number.EPSILON](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number)
        二进制向十进制转换时会丢失精度
        ```js
        equal = Math.abs(a + b - c) < Number.EPSILON
        ```
        https://juejin.cn/post/7210614375290863673

5. amd、cjs、umd
    
    ```js
    // umd
    (function (root, factory) {
      if (typeof define === 'function' && define.amd) {
        define(['loadsh'], factory)
      } else if (typeof exports === 'object') {
        module.exports = factory(require('loadsh'))
      } else {
        root.returnExports = factory(root.loadsh)
      }
    })(this, function () { ... })
    ```
6. 异步与性能


# vue（这里主要解释Vue3即可）

1. vue3优化
    1. 组合式API（Composition API）
    2. monorepo
    3. 响应式原理
    4. TS
    5. Tree-Shaking
2. 响应式原理
    1. Proxy/Reflect
    2. watch/computed
    3. method与computed区别
    4. 如何代理Object、Array、Set、Map
3. 渲染器
    1. 虚拟DOM
    2. Diff算法
        1. 简单Diff
        2. 双端Diff
        3. 快速Diff
4. 组件化
    1. 组件生命周期
    2. setup
    3. 内置插件原理
        1. keep-alive
        2. teleport
        3. suspense
        4. Transition
5. 编译器
6. 其他原理
    1. nextTick原理

        更新响应式状态时，vue不会立即更新DOM，而是将它们缓存到一个队列中，在下一次tick中执行。nextTick是等待DOM刷新的方法。

    2. provide/inject原理
    3. Vue插件
    4. Vue指令
    5. 组合式函数原理（`<script setup>`语法糖做了什么）
7. vue-loader原理：https://github.com/vuejs/vue-loader（没完全理解，后续继续）
    1. vue-loader使用@vue/compiler-sfc解析SFC，生成不同语言的导入
    2. 如果有js-loader，会添加到queries之前，如果有css-loader，会添加到queries之后
    3. 当有扩展请求发起时，vue-loader会将它传递给匹配的loader
    4. 使用Vue-template-compiler编译template；对于style scoped或module：
        1. 在css-loader之前，style-loader之后需要后续处理
8.  router原理
    1. hash只能改变#后面的值，history可以随意设置同源url
    2. hash只能添加字符串类数据，history可以通过API添加多种类型数据
    3. hash不需要服务端配置，history需要服务端配置
    4. hash通过location.hash跳转路由，通过hashchange event监听路由变化
    5. history通过history.pushState()跳转路由，通过popstate event 监听路由变化（但是无法监听history.pushState())
9. 性能优化
 
# TS

1. 相关API
2. TS原理与实现
    1. 枚举实现（js实现）
        ```js
        let enumObj
        (function (obj) {
          obj['apple'] = 'apple'
        })(enumObj || enumObj = {})
        ```

# 工程化

1. webpack（https://www.webpackjs.com/concepts/）
    1. 简单介绍webpack
    2. webpack优化项目
        1. terse、uglify、swc压缩js
        2. gzip、brotli传输压缩
        3. 分析打包体积，替换更小体积的库
        4. 使用支持Tree-shaking的库
        5. 对无法tree-shaking的库进行按需引入
        6. 合理使用browserlist，减少polyfill体积
        7. coded-spliting，按路由加载包（优化性能）
        8. 使用 webpack 的 splitChunksPlugin，把运行时、被引用多次的库进行分包，在分包时要注意避免某一个库被多次引用多次打包。此时分为多个chunk，虽不能把总体积变小，但可提高加载性能 (PS: 此条不减小总体积，但可提升加载性能)
    3. loader原理
        1. CSS Scoped | CSS Module

            scoped内的CSS只作用于当前组件中的元素，但是子组件根元素会受到父组件影响（一般用于布局）。scoped组件如果想深层次影响子元素样式，需要::v-deep()。

            - css specificity，scoped样式是类 + 属性选择器的一种，它的权重优先级高于类选择器，但是性能低于类选择器和ID选择器。
            - 因为使用的类选择器字符是固定的，所有有可能被祖先节点同名类样式影响。
            - 递归组件应该避免使用scoped，尤其是scoped内部包含后代选择器，性能损耗极大。可以将样式抽出，进而避免内存损耗

            vue-style-loader css-loader modules: true打开，然后可以替代scoped方案：

            1. module可以像JS对象一样使用，甚至可以传递给子组件
            2. 最后生成的是类选择器，类名随机，与scoped的类属性选择器不同
    4. webpack HMR原理
        
        在不刷新页面的情况下更新内容。

        webpack watch模式下，webpack-dev-server(WDS)会监听代码变更，并与浏览器建立websocket连接，当代码变更时会

    5. plugin
        
        1. 什么是plugin：用来解决loader无法解决的问题，比如性能优化和代码压缩。plugin加载之后，在webpack构建的某个时间节点会触发plugin
        2. 原理（执行时机）
        3. 常用的插件
            1. html-webpack-pluign：处理html资源，默认会创建一个空的 HTML，自动引入打包输出的所有资源（js/css）
            2. mini-css-extract-plugin：打包过后的 css 在 js 文件里，该插件可以把 css 单独抽出来
            3. clean-webpack-plugin：每次打包时候，CleanWebpackPlugin 插件就会自动把上一次打的包删除
    6. webpack构建流程
    7. 性能优化
        1. 代码压缩
        2. tree-shaking
    8. loader和plugin区别
        1. loader本质是一个转换器
        2. plugin：webpack在运行期间会广播一些事件，plugin通过监听这些事件，使用webpack API改变输出结果
            
            


2. vite
    1. rollup及vite简介
    2. 插件原理
3. tree-shaking原理
    1. 基于ESM进行静态分析，通过AST将未引用的代码移除，减少打包体积
    2. webpack会先标记未使用的代码，然后再UglifyJSPlugin中删除代码
4. npm包
    1. 本地如何发包
5. 仓库管理
    1. monorepo + lerna
6. docker
7. git
    1. git rebase和git merge区别：merge就是正常的合并，git分支是交叉的。rebase会以一个分支为基础，将另一个分支在交叉提交之后的所有提交连接到当前分支上，之后分支不存在交叉。
    2. hook：git在执行的时候会抛出一些同步钩子
8. vite、webpack是如何实现css-module的（为什么可以通过ESM导入的方式导入CSS文件）
9. ts-loader做了哪些事情
10. vite和webpack比较
    
    webpack是一个构建工具，对标rollup，vite是在rollup基础上构建的工具。相当于添加了一些loader、plugin的rollup工具。

# election
    1. v8
# nest + typeorm
# python + django

# 项目问题

1. 自研图形引擎Design Graph
    
    Mdesign3使用的MXGraph自定义图形难维护、图形扩展难度大性能低、框架体积大、不方便跨平台与复用。

    graph是独立的组件，以支持跨平台和跨项目。组件内支持响应式，向外导出graph类。图形扩展通过插槽实现。

    缺点：只是ui组件，不能进行业务，导致需要在组件和Node维护相同逻辑；性能不太好，尤其是多层级图形组件；

    项目间缺点：组件由多个项目使用，但是维护仅有MDesign工具组。导致其他组使用组件难度大

2. node层

    扩大事务概念为步骤。ui层请求node会进入事务然后产生步骤id，然后传递给后端，后端会返回模型变更数据，node层再处理，如果数据发生变更，会将步骤保存。以支持前进后退。步骤id用于保持数据一致性。

    删除通过修改isDelete字段实现

    更新相当于拷贝原来数据、然后删除、然后新增。

    分段处理数据，需要保存事务状态。然后修改事务中数据的变更。

3. 技术缺点
    
    node层很多余，且前端没有对node进行分层，而是前后端都写。大部分人对ui层更熟悉，node代码很混乱。因为是核心工具，其他项目组成员有时也会来上手代码进行对应项目交接。

    前后端是链式请求的，node层积累大量中间接口。因为业务的特殊性，Node层和后端是单线程的。

4. 为什么M-Design项目中没有使用状态管理工具

    1. 当时vue3生态不是很完善（比如element-plus有很多问题）
    2. Action这种设计在后续开发中有点无心插柳的意思。

        1. Action的设计与VueX、Pinia很相似
        2. 比如本机多用户登录，直接实例化一个新的ActionManger即可。如果是使用状态管理工具，需要更高的成本。
        3. 类扩展与开发相对方便，Action依赖class的Extends易于扩展，代码要比状态管理工具简介。

5. 术语库设计（先了解i18n插件）

    需求：统一各个项目产品文案、包括各类专业术语、文案话术、时间日期数字格式
    
    第一版：i18n，单个项目内

    第二版：抽离为组件库，封装了i18n，约束时间日期数字格式。一套公共术语、话术。每个项目单独维护一个json用于特殊文案。

    缺点：
    后端返回的内容由语句变为术语，不利于开发。

6. 项目问题

    1. 产品人员离职太频繁，导致开发、测试占主导地位。研发没有自我意识，更倾向于甲方定制，非常被动
    2. 职能不明确，除了开发、测试能直接干扰需求，领导层也能干扰需求并调用研发人员。需求评审只有一个阶段
    3. 有些项目没有项目经理，各项目之间沟通困难
    4. 缺少技术共享，生态迟迟无法建立

7. Mdesign4项目打包问题
    1. 为什么选择webpack + electron
    2. 如何打包成`.exe`程序
    3. 打包后路径问题
    4. Node、Java如何进行交互

# 有什么想问面试官的

    1. 现有项目开发中，前端有架构师介入吗？
    2. 产品研发的流程
    3. 开发团队中有技术分享吗？
    4. 对我今后学习方向有什么建议？

> ### 面试中如果遇到问题，回来后及时做总结，然后得出详细思路
