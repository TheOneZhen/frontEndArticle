# 数据类型 & 类型判断
通常来讲，数据类型和类型判断都可做为一大章内容来介绍，但是在大家对这俩块知识点耳熟能详的前提下分开探究，显得分立。

MDN [JavaScript 数据类型和数据结构](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures)一篇中将js数据类型分为俩大类：[原始值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%8E%9F%E5%A7%8B%E5%80%BC)和[Object](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#object)。因为**原始值**术语有些难懂，所以下文以[基本数据类型](#基本数据类型)映射原始值，[引用数据类型](#引用数据类型)映射Object来介绍js数据类型。
> MDN对数据类型的描述很详细，我们将在MDN的基础上补充原理
## 基本数据类型
- Null
  
  Null数据类型只有一个值：null，通常被用来表示没有**对象**：
  ```js
    typeof null
  ```
  ```js
    // output
    'object'
  ```
  是不是很神奇，null可以当作一个对象来看待。**那为什么要把Null放到[基本数据类型](#基本数据类型)里介绍呢**？
  > 其实，区分一个数据类型是基本数据类型还是引用数据类型并不是依据这个数据类型是否为对象，如果以对象做为界定标准，那js中所有类型都是引用数据类型了，**一切皆对象**就可以叫成**一切皆引用数据类型**。基本数据类型是一种不可变类型，任何操作都不会改变其值本身，而是返回对值的操作结果，后续我们再详细介绍。
  
  js中null的应用少得可怜：
  - [原型链末端](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)，这个非常重要。从这一处我们也可以看出，为什么null被当作对象来看待
  - Object的一些静态方法，比如`Object.create()`，可以将null作为参数传进去；再比如`Object.getPrototypeOf`（下面这段代码有一个更神奇的地方，在**类篇**中有介绍）：
    ```js
      const a = Object.create(null);
      Object.getPrototypeOf(a);
    ```
    ```js
      // output
      null
    ```
  类型判断很直接：
  ```js
    function isNull(x) {
      return x === null;
    }
  ```
  
  null做为[关键字](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar)存在，直接被JE识别，不能做任何赋值操作。介绍null这一特点其实无关紧要，因为开发过程中是和undefined同等看待的，不过我们再细究undefined，就会发现一些有趣的现象。

- undefined

  undefined类型也只有一个值：undefined，通常被用来表示没有值，是一个全局属性，会在以下场景中被默认返回：
  - `return;`语句会隐式返回undefined，如果你想让你的函数更语义化，可以根据返回值的类型确定是`return undefined;`还是`return null;`
  - 访问不存在的对象属性
  - 变量声明时没有初始化会被默认初始化为undefined（这也是变量提升问题中，初始化前变量值为undefined的原因）
  - 标准内置对象的一些方法，比如Array.prototype.find(), Map.prototype.get()，当没有发现元素时返回undefined
  
  类型判断也很直接：
  ```js
    function isUndefined(x) {
      return x === undefined;
    }
  ```

  与null不同，undefined是一个普通的标识符，也就是你可以对它这么干：
  ```js
    undefined = 1
  ```
  ```js
    // output
    1
  ```
  不过没什么意义，因为不能改变undefined。这就是null中我们说的有趣的现象（似乎又不是很有趣）。

- Number
  - [Number.EPSILON](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON)：该属性表示一个数字最邻近浮点数与它的差
    > 常见面试题《0.1 + 0.2 !== 0.3》中会应用到这个属性。在二进制中也存在无限小数（类比十进制中1/3），但是IEEE精度是有限的，导致遇到这类数字时不得不丢失精度。比如0.3对应的二进制是0.01001100110011...：
    ```js
      equal = Math.abs(a + b - c) < Number.EPSILON
    ```
    可以理解为在约定的误差下认为它们是相等的
- BigInt
  - 与Number相互运算，会抛出TypeError
  - 不符合IEEE 754
  - 与Number之间的转换会存在精度丢失，浮点数也有精度丢失的情况
- Symbol
  - 不能使用其他操作符
  - 一般被用来创建匿名且不可枚举的属性
    ```js
      const myPrivateMethod = Symbol();
      this[myPrivateMethod] = function() {...};
    ```
    - 因为不可枚举，无法作为for...in...的成员出现
    - 因为匿名，不能被Object.getOwnPropertyNames()访问，但可以被Object.getOwnPropertySymbols()访问
  - symbol注册表的内容不会出现在js运行环境，只有通过中间方法获取（Symbol.for，Symbol.keyFor()）

- 基本数据类型通用特性
- 基本数据类型的值是[不可变](https://developer.mozilla.org/zh-CN/docs/Glossary/Immutable)的，即任何操作不会改变原始值本身，而是返回对原始值的操作结果
- 拆箱与装箱
  - 基本数据类型是没有属性的，但是在js中，基本数据类型构建后有一些默认的方法属性，且给基本属性加上属性不会抛出TypeError错误
  - 显示拆箱
    - toString()，valueOf()这种
  - 显示装箱
    - 通过构造函数声明基本数据类型
    - 基本数据类型的属性都是装箱（通过构造函数的隐式装箱）时添加的

## 引用数据类型
- 对象属性
  - 数据属性
    - [[Value]] = undefined
    - [[Writable]] = false
    - [[Enumerable]] = false
    - [[Configurable]] = false
  - 访问器属性
    - [[Get]] = undefined
    - [[Set]] = undefined
    - [[Enumerable]] = false
    - [[Configurable]] = false

## 基本数据类型和引用数据类型的区别
- 存储区别
  - 引用数据类型引用的数据存储在堆中，但是指针（声明的引用变量）和基础数据类型一样，都是存在栈中

## Q&A
1. 既然基本数据类型存在装箱和拆箱，那是不是和引用类型没有什么区别，为什么会被保存到不同的位置呢

## reference
1. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures