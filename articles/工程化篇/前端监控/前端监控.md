随着应用技术升级，前端监控变得尤为重要。本篇将从前端监控内容入手，去了解前端监控的各项细节。

# 监控内容

## 语法错误

语法错误`SyntaxError`无法被`try-catch`捕捉，所以该类错误应该尽可能在开发阶段避免，在打包阶段进一步筛选问题，以防发布到生成环境。

## 同步错误

同步错误可以被`try-catch`捕捉，同步错误包括：指向错误`ReferenceError`、类型错误`TypeError`等。代码示例（浏览器与nodejs同）：

```js
try {
    const aaa = 'hello world!'
    console.log(aa)
} catch (e) {
    console.error(e) // ReferenceError: aa is not defined
}
```
## 异步错误

异步任务无法被`try-catch`捕捉，比如浏览器环境下`setTimeout`、`setInterval`以及`fetch`等API，这些任务会被存储起来，需要订阅错误消息才能**被捕捉**。

1. 浏览器环境下使用[`window.onError`](https://developer.mozilla.org/en-US/docs/Web/API/Window/error_event)

    ```js
        window.onerror = (event, source, lineno, colno, error) => {
            console.log(`
                可读的错误信息描述${event}
                错误脚本的URL字符串${source}
                发生错误的行${lineno}
                发生错误的列${colno}
                抛出的错误${error}
            `)
        }
    ```

    这个API不能捕获`Promise`错误。

2. nodejs环境

    一般地，可以通过监听[`uncaughtException`](https://nodejs.org/api/process.html#event-uncaughtexception)事件捕获错误：

    ```js
    try {
        setTimeout(() => {
            throw new Error('这是一个错误')
        })
    } catch (e) {
        console.error(e.message)
    }

    process.on('uncaughtException', e => {
        console.error('uncaught Exception:', e.message)
    })
    ```

    `uncaughtException`可以捕获整个node进程中未捕获的错误信息，但是nodejs环境区别于浏览器环境，当一段代码抛出错误后意味着丢失上下文。比如客户端请求错误，虽然被`uncaughtException`捕获，但此时不会再返回信息给客户端。客户端只能在请求超时时才能获取`no data received`错误。再者，`uncaughtException`会导致nodejs不能正常进行内存回收，引发内存泄露（[Warning: Using 'uncaughtException' correctly](https://nodejs.org/api/process.html#warning-using-uncaughtexception-correctly)）。

    这里不再细致介绍，这里给出俩个参考点：

    1. [nodejs 错误异常的捕获](https://juejin.cn/post/7249991926307799077?searchId=2024080601505292470F027DFB8203A315)：这篇文章最后采用多进程 + `domain` + `uncaughtException`的方案，但是注意`domain`模块可能随时被移除。
    2. [nest decorator @catch()](https://github.com/nestjs/nest/blob/master/packages/common/decorators/core/catch.decorator.ts)

## Promise错误

nodejs环境可以通过上面介绍的方式进行捕捉，浏览器环境可以通过[`unhandledrejection`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unhandledrejection_event)事件监听。

## 资源加载错误

这个仅发生在浏览器环境，会导致页面无法正常展示。可以使用`window.addEventListener('error', () => {})`捕获，这个和上面介绍的`window.onerror`有一些差异，表现在：

1. `window.onerror`是一个全局变量，默认值为null。`window.onerror`拥有更多的参数，可以细致到源码行列数，`window.addEventListener`只有错误信息；
2. `window.addEventListener`比`window.onerror`先触发，且`window.addEventListener`可以监听资源加载的错误（监听DOM错误）；
3. 俩者捕获到错误时，都代表错误代码的下文（下一行）无法继续执行。

`window.addEventListener`代码示例：

```js
window.addEventListener("error", (event) => {  
    if (event.target instanceof HTMLImageElement || event.target instanceof HTMLScriptElement || event.target instanceof HTMLLinkElement) {
        console.error("资源加载错误:", event.target.src || event.target.href)
    }
});

```
