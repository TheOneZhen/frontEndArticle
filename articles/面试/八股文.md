# CSS

1. H5新特性
    语义化标签：引入了许多新标签，有益于SEO和页面的可访问性
    表单增强：比如input标签type为color、date、number等
    支持视频和音频
    canvas
    web存储
    位置信息
    web worker
    web socket
    CSS3支持：选择器、border-raidus、box-shadow、渐变色、transition、animation @keyframes、transform、字体相关、灵活布局、过渡效果、媒体查询
2. 如何实现一个元素的水平垂直居中
    1. son：absolute + transform(tanslate(50%, 50%))
    2. container(flex) + son(margin: auto)
    3. container(grid) + son(margin: auto)

3. 响应式布局
    > 主轴和交叉轴都可能有多个

    1. Multicol（多列）
        1. column-count：列数
        2. *-gap：间隙
        3. *-rule：添加分割线
        4. break-inside：多列布局下内容盒子如何中断
    2. Flex Box（弹性盒）
        1. flex-direction\wrap\
        2. flex = grow shrink basis
        3. flex-basis在纵向排列时代表height，为最优选
    3. Grid
        1. 1fr，一份
    4. align-content：分配**多行内容**交叉轴方向剩余空间
    5. justify-content：分配主轴方向剩余空间
    6. justify-items：设置容器内每个元素主轴方向的justify-self
    7. justify-self: 设置元素相对于其交叉轴的对齐方式
    8. align-items: 设置每个元素的align-self
    9. align-self：设置元素相对于其所在主轴对齐方式
    10. place-content = align-content justify-content
    11. place-items = align-items justify-items
4. 标准盒和怪异盒

    content-box'width = content
    border-box'width = border + padding + content

5. FC（文档流，Formatting Context）

    页面中的一块渲染区域，有自己的渲染规则，决定其子元素如何布局以及和其他元素之间的关系和作用。

    1. BFC（区块格式化上下文，Block Formatting Context）（GFC、FFC也是一个BFC）
        
        块级盒子布局时，BFC为其提供隔离环境，使其不影响容器外布局，元素在这个环境中按照一定规则进行布局。

        1. 创建： 根元素、浮动元素、悬浮元素、display: flex\inline-block\table\grid、overflow：hidden|auto|scroll
        2. 特性：
            1. BFC 是一个独立的容器，容器内子元素不会影响容器外的元素。反之亦如此。
            2. 盒子遵照一些规则有序排列
            3. 相邻盒子margin-top-bottom会发生重叠
            4. BFC包含浮动元素时（另一个BFC），浮动元素也会参与区域高度计算
        3. 作用
            1. 清除浮动（或使用clearfix）：浮动元素会覆盖普通文档流，但是不会覆盖BFC
            2. 阻止margin-top\margin-bottom合并：外部元素不会影响BFC布局
            3. 阻止容器高度塌陷：浮动元素参与区域高度计算
    2. IFC（行级格式化上下文）

        行级元素包括：a\img\picture\span\input\select\textarea\label

        1. 创建：块级元素中仅包含行内元素
        2. 特性：
            1. 水平横向排列，垂直方向起点是父元素顶部
            2. 只计算横向样式（ml\mr\pl\pr\border），行高由CSS行高计算规则来确定
            3. 垂直方向可使用（vertical-align）进行布局
            4. 如果宽度小于容器宽度，由text-align决定水平分布，超出容器宽度可以会溢出，可以设置white-wrap换行。

6. CSS伪类和伪元素
    
    伪元素会在文档流生成新的元素，使用content属性可以设置内容

    伪类可以定义元素在不同状态下的样式，或者选择元素（比如：is ：not：has）。

7. CSS样式优先级

    内联样式 > ID选择器 > 类选择器（类、属性选择器、伪类） > 类型选择器（标签、伪元素）

    ！importment会破坏CSS specificity

8. 优化关键渲染路径（css性能优化）
    1. 如果css文件很大，阻塞了渲染，应该对样式表进行拆分。可以通过media告诉浏览器哪些内容在当前渲染中是重要的，不重要的css浏览器也会下载，但是不会阻塞渲染
    2. 将元素提升为图层，使动画转换在GPU上进行，从而提升性能。属性包括：transform、opacity、will-change、filter、animation；相关标签包括：video、canvas、iframe
    3. will-change可以告诉浏览器，元素的哪些属性需要修改，使浏览器提前做出优化

        ```css
        will-change: opactiy, transform;
        ```
    4. font-display：字体包体积比较大，在下载期间需要过渡字体。
    5. contain：标记独立的区域，区域样式变化时，浏览器会针对性的重新布局
    6. 禁止使用@import，此时如果从css文件没有下载，会等待下载，再继续渲染

# 浏览器

1. 从输入url到展示页面浏览器做了那些事情。
    1. 根据URL获取IP地址，可能是本地缓存，也可能是进行DNS查询
    2. TCP握手
    3. TLS协商（Transport Layer Security）
    4. 浏览器获取资源
        1. 如果本地存在缓存，判断缓存是否过期，如果没有过期，复用。如果过期发送Get请求获取资源。
        2. 如果本地不存在缓存，发送GET请求获取资源
    5. 如果资源是HTML。开始解析
        1. 解析之前进行一次预加载扫描
            1. 如果遇到rel=preload资源，请求获取资源
            2. 如果遇到CSS、JS文件，请求获取资源
        2. 解析HTML生成DOM
            1. 如果遇到CSS文件，请求资源
            2. 如果遇到script文件
                1. 如果是defer，请求资源，并在HTML解析之后执行脚本
                2. 如果是async，请求资源，待资源下载完毕立即执行脚本
                3. 如果都没有，阻塞HTML解析，一直到脚本下载完毕并且执行完毕
        3. 触发domcontentLoaded事件
    6. 解析完毕后开始构建CSSOM
        1. 如果有CSS文件没有下载完全会阻塞渲染
        2. 如果CSS文件中包含@import，阻塞渲染，下载文件
    7. DOM和CSSOM合并成render tree
        1. 布局：从Render Tree根节点开始，确定节点的大小和位置
        2. 绘制：将可见部分绘制到屏幕上
        3. 合成：将文档中不同层按正确的顺序合并到一起
    8. 触发load事件
    9. 页面展示。
    
2. 什么是跨域，同源策略。（https://www.bilibili.com/video/BV1Bk4y1W7ht/?spm_id_from=333.337.search-card.all.click&vd_source=fe81433332628c7f76960485cdf9a9e4）

    跨域：资源的域名、协议、端口不同

    同源策略：限制不同域资源之间的交互

    1. 跨域资源共享（CORS）：服务端响应头添加：Access-Control-Allow-Origin: *
    2. 代理转发：反向代理中配置目标域名（或资源路径）（服务器代理请求的资源）
    3. JSONP
        
        HTML src属性引用资源不会触发SOP（同源策略）

        ```js
        function jsonp(url, params, CB) {
          const script = document.createElement('script')
          script.src = `${url}?${stringify({ callback: "padding", ...params })}`
          window['padding'] = CB
          document.body.appendChild(script)
        }
        ```
        缺点：
        1. 只支持GET
        2. 需要后端配合，如果后端不可控，可能存在代码注入的风险
        3. 无法监听接口异常
    4. postmessage


3. preload与prefetch
    1. preload用于提前加载当前界面资源，浏览器在解析HTML的时候会识别此属性优先加载资源
    2. prefetch用于提前加载其他界面资源，会在loaded之后进行

4. 异步加载脚本async与defer
    https://html.spec.whatwg.org/images/asyncdefer.svg
    async在脚本下载完后，立即执行（可能会阻塞HTML解析）
    defer在异步下载脚本，并在HTML解析之后，DomContentLoaded之前执行

5. DomContentLoaded与load
    1. HTML解析完成后，DomContentLoaded事件触发
    2. 当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件

6. 浏览器使用ESM
    1. Module默认defer
    2. Module是单独作用域，不会污染到全局（IIFE）
    3. Module是strict
7. window
    1. requestIdleCallback：在浏览器空闲的时候执行函数（一般用于低优先级的任务）
    2. requestAnimationFrame：在浏览器下一次重绘之前调用指定函数更新动画
    3. postmessage：进程间通信
    4. queuemicrotask：微函数执行栈
    5. matchMedia
    6. getSelection
    7. MutationObserver：可以用来监视DOM Tree的变化
8. iframe（微前端篇）
9. 图形绘制
    1. svg
        1. 矢量图形、可以添加事件处理器、可以使用css、结合Vue相对简单
        2. 性能差，不适合渲染大量动态图形（在单一图层，没有GPU参与）
    2. canvas
        1. 只能绘制栅格图形，不能绘制矢量图形、不支持事件处理器、缩放困难、动画需要手动实现
        2. 性能好（只考虑结果，不考虑过程）

# 计算机相关

1. TCP（看视频理解）
    1. 三次握手（https://www.bilibili.com/video/BV18h41187Ep/?spm_id_from=333.337.search-card.all.click&vd_source=fe81433332628c7f76960485cdf9a9e4）
        1. 客户端发送SYN
        2. 服务端接收SYN，响应SYN + 1、ACK + 1
        3. 客户端发送ACK + 1
    2. 四次挥手（https://www.bilibili.com/video/BV18h41187Ep/?spm_id_from=333.337.search-card.all.click&vd_source=fe81433332628c7f76960485cdf9a9e4）
        1. 客户端发送FIN + ACK
        2. 服务端接收FIN，响应ACK + 1
        3. 服务端发送FIN + 1、ACK + 1
        4. 客户端收到后发送ACK + 1
    3. keep-alive：客户端连接失效后，服务端不知道何时关闭连接，会自动发送报文检测客户端是否正常运行。（和http不同）
2. TCP和UDP的区别
    1. TCP基于连接，UDP基于非连接
    2. TCP可以保证数据顺序，UDP无法保证
    3. TCP面向字节流，UDP面向数据报文
    4. TCP可以保证数据完整性。UDP可能会丢包
3. 安全（这里总结的不是很详细）
    1. XSS（Cross Site Scripting，跨站脚本攻击）（https://www.bilibili.com/video/BV1Qd4y1k7K4/?spm_id_from=333.337.search-card.all.click&vd_source=fe81433332628c7f76960485cdf9a9e4）

        向网站注入恶意脚本。
        
        攻击方式：伪造输入框、GET请求恶意参数

        预防：
        1. 输入校验
            1. 对输入格式进行校验，比如输入的账户是否是邮箱
            2. 对注入的内容过滤掉一些标签、事件属性
        2. 输出校验
            1. 对渲染的内容进行编码转义
            2. cookie设置为http-only，防止信息被窃取

    2. CSRF（Cross-site request forgery，跨站请求伪造）
        
        恶意伪造请求。

        预防：请求中添加CSRF-token，服务端接收请求验证token是否正确，如果不正确直接丢弃。前端cookie最好设置为http-only，防止攻击者拷贝cookie

    3. 点击劫持

        攻击者使用iframe将网站嵌入到自己的页面，然后伪造输入框覆盖原来的输入框，从而获取用户私密信息。

        解决：资源请求头添加X-FRAME-OPTIONS，禁止未经允许的界面使用iframe获取资源

    4. SQL注入

        服务端对用户的输入没有经过校验就插入数据库中。

    5. DDOS攻击：恶意发送大量请求SYN，导致服务器挂起多个资源并崩溃

        TCP连接，服务端不会保存SYN。

4.  http缓存（https://www.bilibili.com/video/BV17V411J78W/?spm_id_from=333.337.search-card.all.click&vd_source=fe81433332628c7f76960485cdf9a9e4）
    1. Expires：优先级等于cache-control，直接约定换缓存到期时间
    2. cache-control
        1. cache-control请求头包含属性：max-age、no-cache、no-store 
        2. no-cache与no-store区别
            1. no-cache可以在客户端缓存资源，但是每次都必须请求服务器检查新鲜度，来决定是从服务器获取最新资源（200）还是从客户端读取缓存（304），即协商缓存
            2. no-store不使用任何缓存
        3. public：可以缓存到中间节点和客户端
        4. private：只能在客户端缓存
    3. 强缓存：通过cache-control中max-age控制。不会向服务器发送请求
    4. 协商缓存：访问缓存前需要进行新鲜度校验（有些不清晰）
        1. 通过比对etag和if-none-match
        2. if-modifie-since和last-modified和对比
    5. ETAG：服务端如何校验客户端缓存是否有效
            
        如果是强缓存，第一次请求时服务端会返回ETAG，下一请求时客户端请求头会将ETAG的值塞入if-none-match中。
        如果是协商缓存，第一次请求时服务端会返回ETAG，下一请求时客户端请求头会将ETAG的值塞入if-modifie-since和last-modified中

    6. 更有效的缓存：可以按照路由拆分，对于改动不频繁的内容可以设置长期缓存


6.  http2：https://juejin.cn/post/6844903667569541133
    1. http/1.1缺点
        1. TCP连接数限制：对于同一个站点，浏览器只能创建几个TCP连接，所以一般是同一个域名创建几个子域名来增加TCP连接数
        2. 线头阻塞（Head Of Line Blocking）：每个TCP连接同时只能处理一个请求，如果当前请求响应阻塞，后续请求都会受阻。
        3. Header内容多且不会压缩，每次请求都需要携带
        4. 明文传输不安全
    2. http2优势
        1. 二进制分帧层（Binary Framing Layer）：报文消息被划分为更小的数据帧
        2. 多路复用：http/1.1中的帧可以在一次TCP连接中组合成流发送，而不需要创建多个TCP发送
        3. 服务端推送（server push）：客户端还没有请求，服务端就把一些必要的内容推送过去：http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html
        4. Header压缩（HPACK）
        5. 应用层的重置连接：可以在不断开连接的前提下取消stream
        6. stream请求优先级
        7. 流量控制
7.  https = http + tls
    1. http缺点：http内容使用明文传输，在传输过程中被劫持后传输内容完全暴露。不能判断数据是否被篡改。
        1. 数据明文传输
        2. 缺乏消息完整性检测
    2. https使用对称加密和非对称加密（CA数字签名 + 数字证书用于证明密钥的真伪）
    3. TLS协商
        1. 客户端发送请求并携带密码组合、随机数1
        2. 服务端响应密码组合和CA证书、随机数2
        3. 客户端发送随机数3，密钥生成
        4. 双方互发FIN
    4. 每次https请求都需要生成密钥吗
        1. 不会，服务器会为每个浏览器生成sessionId，在TLS握手阶段传给浏览器，之后浏览器的请求自动带上sessionId
8.  cookie访问范围
    1. 包含的属性domain、expire（max-age）、path、HTTPonly、secure、samesite
    2. localhost:3000 与 localhost:5000 的 cookie 信息是否共享：这个和domain、path字段有关，如果这俩个字段相同就共享
    3. secure设置后，不安全的站点无法修改cookie，且发送请求的时候不会将cookie发送给服务端
    4. httponly设置后，浏览器无法访问此类cookie，该cookie只用于服务器
    5. samesite
        1. strict：完全禁止跨站点请求携带cookie
        2. lax：链接（href）、预加载（preload）、GET表单可以携带cookie，其他不允许
        3. None
9.  get和post区别
    1. 浏览器回退，GET无影响，POST会再次请求
    2. GET产生的URL地址可以收藏、转发，POST不可以
    3. GET请求会被浏览器主动缓存，POST需要手动设置
    4. GET请求只能进行URL编码，POST支持多种编码方式
    5. GET请求参数随URL被记录到浏览器中，POST不可以
    6. GET请求参数有长度限制，POST没有
    7. GET请求参数直接暴露在URL上不安全，不适合放置敏感信息，POST是放在RequestBody中
10. http status code（https://zhuanlan.zhihu.com/p/603410395）

# js

1. V8垃圾回收机制（x）
2. 作用域与闭包（文章）
3. this和对象原型（文章）
4. 类型与语法（文章）
5. amd、cjs、umd（文章）
6. 异步与性能
7. 事件循环（https://github.com/dwqs/blog/issues/61）（https://www.zhihu.com/question/268007969）
    1. web事件循环（chrome，async-await性能优化）
    2. node事件循环
8.  手撕代码
    1. Promise：https://zhuanlan.zhihu.com/p/183801144
    2. 算法
        1. 排序（https://mp.weixin.qq.com/s/a0LGAlPD2Rs60Cb4Uz0hwQ）

# nodejs

# vue（这里主要解释Vue3即可）

1. vue3优化：
    1. 代码管理：monorepo、更好的支持TS
    2. 语法
        1. 组合式API（Composition API）
    3. 性能
        1. 响应式原理
        2. 体积减小：Tree-Shaking、删除不必要的API（一些实例属性$on$off$emit）
2. 响应式原理

    在读取(get)响应式数据的时候，收集副作用函数；在操作（trap in set, ownKeys, deleteProperty, has）响应式数据的时候，触发副作用函数。
    ？？通过谁触发？？
    响应式数据会被存储到该数据结构中：`type Bucket = WeakMap<any, Map<string, Set<Function>>>`;
    第一层weakmap映射是原始数据：对象中每个KEY，第二层数据时KEY：变更时产生的副作用函数
    
        

    1. Proxy/Reflect
    2. watch/computed
    3. method与computed区别
    4. 如何代理Object、Array、Set、Map
        
        get、set、ownkeys、has、deleteProperty

3. 渲染器
    1. 虚拟DOM
    2. Diff算法：
        1. 简单Diff
        2. 双端Diff
        3. 快速Diff（https://www.bilibili.com/video/BV1JR4y1R7Ln/?spm_id_from=333.337.search-card.all.click&vd_source=fe81433332628c7f76960485cdf9a9e4）及时剪枝（tag、key）
4. 组件化
    1. 组件生命周期
    2. setup
    3. 内置插件原理
        1. keep-alive
        2. teleport
        3. suspense
        4. Transition
5. 编译器
6. 其他原理
    1. nextTick原理

        更新响应式状态时，vue不会立即更新DOM，而是将它们缓存到一个队列中，在下一次tick中执行。nextTick是等待DOM刷新的方法。

    2. provide/inject原理
    3. Vue插件
    4. Vue指令
    5. 组合式函数原理（`<script setup>`语法糖做了什么）
7. vue-loader原理：https://github.com/vuejs/vue-loader（没完全理解，后续继续）
    1. vue-loader使用@vue/compiler-sfc解析SFC，生成不同语言的导入
    2. 如果有js-loader，会添加到queries之前，如果有css-loader，会添加到queries之后
    3. 当有扩展请求发起时，vue-loader会将它传递给匹配的loader
    4. 使用Vue-template-compiler编译template；对于style scoped或module：
        1. 在css-loader之前，style-loader之后需要后续处理
8. router原理
    1. hash只能改变#后面的值，history可以随意设置同源url
    2. hash只能添加字符串类数据，history可以通过API添加多种类型数据
    3. hash不需要服务端配置，history需要服务端配置
    4. hash通过location.hash跳转路由，通过hashchange event监听路由变化
    5. history通过history.pushState()跳转路由，通过popstate event 监听路由变化（但是无法监听history.pushState())
9.  router执行流程
    导航被触发。
    在失活的组件里调用 beforeRouteLeave 守卫。
    调用全局的 beforeEach 守卫。
    在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。
    在路由配置里调用 beforeEnter。
    解析异步路由组件。
    在被激活的组件里调用 beforeRouteEnter。
    调用全局的 beforeResolve 守卫(2.5+)。
    导航被确认。
    调用全局的 afterEach 钩子。
    触发 DOM 更新。
    调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。
10. 性能优化
    1. block
    2. 静态提升
 
# TS

1. 相关API
2. TS原理与实现
    1. 枚举实现（js实现）
        ```js
        let enumObj
        (function (obj) {
          obj['apple'] = 'apple'
        })(enumObj || enumObj = {})
        ```

# 工程化

1. webpack（https://www.webpackjs.com/concepts/）
    1. 简单介绍webpack

        静态模块打包工具。可以进行模块打包、编译兼容、能力扩展。

    2. 构建流程
        
        初始化参数 -> 开始编译 -> 确定入口 -> 编译模块 -> 完成模块编译 -> 输出资源 -> 输出完成

        输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk加入输出列表

    3. webpack优化项目
        1. 开发环境优化
            1. 升级新版本
            2. 优化搜索文件
            3. 避免重复编译第三方库
            4. 开启多进程Loader转换
            5. 开启模块热更新（HMR）
        2. 生产环境优化
        
            1. terse、uglify、swc压缩js
            2. gzip、brotli传输压缩
            3. 分析打包体积，替换更小体积的库
            4. 使用支持Tree-shaking的库
            5. 对无法tree-shaking的库进行按需引入
            6. 合理使用browserlist，减少polyfill体积
            7. coded-spliting，按路由加载包（优化性能）
        3.  使用 webpack 的 splitChunksPlugin，把运行时、被引用多次的库进行分包，在分包时要注意避免某一个库被多次引用多次打包。此时分为多个chunk，虽不能把总体积变小，但可提高加载性能 (PS: 此条不减小总体积，但可提升加载性能)

    4. webpack HMR原理
        
        <img src="https://pic1.zhimg.com/80/v2-f7139f8763b996ebfa28486e160f6378_720w.webp" />

        在不刷新页面的情况下更新内容。

        webpack-dev-server(WDS)监听代码变更，并与浏览器建立websocket连接，当代码变更时会将变更文件通知浏览器，浏览器通过JSONP获取更新内容替换。

        拿到增量更新内容后，由HotModulePlugin插件继续后续处理。比如vue-loader中使用了一些此插件的API来进行热刷新。

    5. plugin（https://juejin.cn/post/6844904094281236487?searchId=202309140902037E7B885A524345A065C2）
        
        1. 什么是plugin：用来解决loader无法解决的问题，比如性能优化和代码压缩。
        2. 原理（执行时机）
            
            插件类在实例化的时候会传入compiler，内置一些钩子，用来订阅构建的各个流程。

        3. 常用的插件
            1. html-webpack-pluign：处理html资源，默认会创建一个空的 HTML，自动引入打包输出的所有资源（js/css）
            2. mini-css-extract-plugin：打包过后的 css 在 js 文件里，该插件可以把 css 单独抽出来
            3. clean-webpack-plugin：每次打包时候，CleanWebpackPlugin 插件就会自动把上一次打的包删除

    6. 性能优化（https://zhuanlan.zhihu.com/p/139498741）

        1. 分析工具：webpack-bundle-analyzer
        2. 构建速度优化
            1. 代码压缩：使用terser-webpack-plugin压缩JS代码，使用css-minimizer压缩css代码，使用htmlwebpackplugin压缩html
            2. 资源压缩：配置image-loader压缩图片
            3. tree-shaking

                依赖于ESM静态语法分析，用于消除死代码。`usedExports`在未使用的函数标注，在terser中优化。`sideEffexts`跳过模块/文件（package.json中设置）

            4. 缩小打包范围：使用include和exclude
            5. 对于多页面应用，提取公共代码
            6. 使用缓存。cache-loader
            7. 使用DDL，避免静态文件重复打包
            
    7. 文件指纹

        打包后文件名

        [ProjectHash]-[ChunkHash]-[contentHash].js

        ProjectHash：项目发生改变时，整个项目hash都会变更。
        chunkhash：和chunk有关，不同entry的chunkhash值不同
        contenthash：根据文件内容定义hash

2. vite
    1. rollup及vite简介
    2. 插件原理
3. tree-shaking原理
    1. 基于ESM进行静态分析，通过AST将未引用的代码移除，减少打包体积
    2. webpack会先标记未使用的代码，然后再UglifyJSPlugin中删除代码
4. npm包
    1. 本地如何发包
5. 仓库管理
    1. monorepo：workspace
        1. pnpm + changeset
6. docker
7. git
    1. git rebase和git merge区别：merge就是正常的合并，git分支是交叉的。rebase会以一个分支为基础，将另一个分支在交叉提交之后的所有提交连接到当前分支上，之后分支不存在交叉。
    2. hook：git在执行的时候会抛出一些同步钩子
8. vite、webpack是如何实现css-module的（为什么可以通过ESM导入的方式导入CSS文件）
9.  ts-loader做了哪些事情
10. vite和webpack比较
    
    webpack是一个构建工具，对标rollup，vite是在rollup基础上构建的工具。相当于添加了一些loader、plugin的rollup工具。

11. CSS Scoped | CSS Module

            scoped内的CSS只作用于当前组件中的元素，但是子组件根元素会受到父组件影响（一般用于布局）。scoped组件如果想深层次影响子元素样式，需要::v-deep()。

            - css specificity，scoped样式是类 + 属性选择器的一种，它的权重优先级高于类选择器，但是性能低于类选择器和ID选择器。
            - 因为使用的类选择器字符是固定的，所有有可能被祖先节点同名类样式影响。
            - 递归组件应该避免使用scoped，尤其是scoped内部包含后代选择器，性能损耗极大。可以将样式抽出，进而避免内存损耗

            vue-style-loader css-loader modules: true打开，然后可以替代scoped方案：

            1. module可以像JS对象一样使用，甚至可以传递给子组件
            2. 最后生成的是类选择器，类名随机，与scoped的类属性选择器不同

# 设计模式

## 分类（https://baijiahao.baidu.com/s?id=1661505290125455712&wfr=spider&for=pc）

1. 行为型模式：一般用于在不同实体之间进行通信
    1. 访问者模式
    2. 观察者模式：当状态发生改变时，会通知订阅此变化的对（一般通过回调的方式）
    3. 策略模式：类中控制一系列行为，比如打折，5折、9折对应不同的操作
    4. 迭代器模式：提供方法，按照一定的顺序方位对象内元素
    5. 解释器模式
    6. 状态模式：类内部状态改变，类的行为也会改变
    7. 责任链模式：对象链式调用内容
2. 创建型模式：提供实例化的方法
    1. 单例模式：提供一个只能实例化一次的类，之后的实例化只能返回第一次实例化的对象
    2. 工厂模式：提供一个抽象化类，用来创建特定类型的对象
    3. 原型模式：新的对象只能通过拷贝原型对象进行创建
    4. 创建者模式：将负责对象的构建与它的表现分离，比如创建车，既可以是创建汽车也可以是创建货车
3. 结构型模式：一般用来处理实体之间的关系
    1. 适配器模式：通过中间类调用另一个接口，类似代理模式
    2. 组合模式：
    3. 代理模式：不直接修改对象，而是通过中间对象代理实现
    4. 装饰模式：动态的给对象添加额外的能力（实际执行可能不仅仅是当前方法）

## solid原则

1. 单一原则：一个类只负责一项职责
2. 里氏替换原则：子类只能替换父类，但是不能修改父类方法
3. 依赖倒置原则：依赖于抽象而不依赖于具体
4. 接口隔离：接口的封装应该最小化，避免代码耦合
5. 开闭原则：对扩展放开，对修改关闭