# 自我介绍

面试官你好，我叫刘振，2021年毕业于浙江农林大学，本科专业地理信息科学。个人过去工作中主要从事前端-跨PC端开发，参与过多个跨PC端项目从0到1的研发。

毕业后一直就职于杭州华望系统科技，负责公司主线产品研发。

公司产品面向工业设计，提供可视化建模服务，包括表格、结构图、思维导图、图表等可视化工具。我任职于设计工具组和生态组，主要负责M-Design4、M-Arch1和M-Cowork的研发，其中M-Design4和Arch参与项目从0到1的研发。

M-Design4在MD3基础上重构，解决痛点，增强可谓维护性。

个人主要技术栈WEB前端框架Vue3，在工作中接触过Electron和Nestjs，熟悉它们在项目中的应用。业余时间学习过Python Django，并使用其建设个人网站，平时会刷算法题。

我的介绍完毕。
# 离职原因

1. 出差频繁；因客户保密需要驻场开发；
2. 行业限制，导致产品人员变动大。使得开发需要负责更多的事务。
3. 技术没有突破，会使个人产生技术惰性，缺乏学习动力，所以坚持离开工作。
4. 其实个人是在22年12月就已经提出离职，但是正好赶上新业务线，所以临时受命没有走。今年5月份版本发布之后才走的，

<!-- 
1. 什么样的场景
2. 遇到什么样的问题
3. 解决方案
4. 最后的结果
5. 与其他方案对比
 -->

# 项目问题

1. M-Design3痛点

    一些痛点功能无法实现（）、三方图形组件自定义困难、项目难以定制化、前后端业务未分离、后端kotlin编译的代码维护、调试困难严重阻碍开发

2. MD业务介绍

    UI层：展示数据、图形，对接MC协同服务
    Node层：处理工程文件、图形等业务，对接后端

3. 状态管理功能

    负责UI层旧代码迁移，发现原来项目功能复用低、状态管理混乱。
    对功能聚类为Action，BaseAction基类定义统一监听事件、二级Action可以视为模块，还能参与模块化打包。比如Project、Graph、User；
    和Pinia组合式语法相似，实例化和Pinia不同。

4. 组件优化

    硬编码组件改为配置 + 组件
    丰富一些组件的细节，比如右键菜单提供快捷键、功能键、局部快捷键；为一些菜单提供动画。增大Electron组件的使用，router + BrowserWindow实现多进程窗口以及主窗口向子窗口通信问题，最后开可以借助SplitChunk实现打包。


5. 痛点功能undo/redo

    数据一致性。前后端建立ws，数据变更的时候Node发送数据，前端负责变动。

6. 快速迭代问题



7. 性能优化
    指标：工程文件处理速度、工程文件打开尺度
    1. 代码层面
        1. 优化接口：优化数量、数据量增大时改为I/O。
        2. 数据处理：设立最小功能单元，优化执行代码。
        3. I/O：使用流读取文件
        4. 数据尺度划分：（后端业务与图形业务处理方式不同）
            1. 数据小的时候，数据库查询全量加载
            2. 数据量大的时候，数据库分批加载。
            3. 以上适合前端数据处理，不适合后端业务处理（后端业务像和尚和舍利子）。
    2. graph
        1. 降低组件层级
        2. 图表类使用虚拟渲染：为了保持数据一致性，数据是全量加载的，DOM的渲染是部分
        3. 增大组件复用
    3. 使用webpack减少代码代码

8. 技术方案输出

    1. 插件系统（管道式）：定义插件接口规范：启动、终止、重启、日志；UI层根据启动命令和启动端口调用Electron执行shell，并提供进程容器包裹插件UI。为了防止插件不合理调用接口，插件只能通过单个接口使用不同参数请求主进程资源，插件系统使用Electron.protocol拦截请求再通过IPC发送至主进程，就可以不是单纯的调用接口，这样不会影响前端状态与数据的不一致。

        其他问题：与vue、webpack、vite插件不同，我们的软件没有提供同步的Hooks，是因为我们插件插入时机不同，我们是在软件运行中使用插件，不能保证hooks动态注入。再者插件不能完全融入主进程，因为一定是单独进程，或者可执行程序。

    2. 术语库

        第一版使用i18n，但是只能用在单个项目内。不同项目组产品会重复做功，而且不能保证文案统一。第二版将其抽离为组件，统一各个项目产品文案、包括各类专业术语、文案话术、时间日期数字格式。暴露出覆盖API，用于不同项目中特殊文案。产品人员维护一个Excel，由脚本转换为JSON，

        缺点：后端返回的内容由语句变为术语，不利于开发。    

9.  定制化业务线与Arch

    背景：需求激增，但多数是在原有功能上进行改进，扩展。为了避免新增代码影响源代码，且支持后续快速化定制，所以独立出此业务线。

    Arch技术栈沿用MDesign4，并以4.1版本为基线。但是在建设过程中，发现它的功能复用程度很大，与定制化业务契合，所以俩个业务线合并。

    难点：对于客户端开发，存在很多配置文件并且独立在不同模块中，定制化业务就是需要把这些配置从原有的业务中抽离出去，统一放置到Node层中，配合环境变量，实现定制化。但是配置文件的抽离会破坏模块化设计且不利于项目合并，所以使用运行时请求并替换配置文件。

    三方集成：和其他公司合作的项目，独立为插件，然后参与定制化

10. 甘特图

    技术调研阶段：调研了一些开源框架和市面上流行的产品比如飞书，发现了一些问题：

    1. 难以和我们的业务相结合
    2. 使用了canvas，虽然在性能上表现好，但是项目中没有canvas基础，从0开发需要引入大量插件，比如事件监听，滚动监听等，而且canvas没有template层级结构，不利于后续维护。

    方案选用：将甘特图分为俩部分，表格和图表，甘特图表格部分使用了el+，图表部分使用DOM渲染时间条，结合dayjs完成时间线。时间条使用相对定位 + margin进行偏移。通过监听表格部分滚动条，实现懒渲染。

    细节上的考虑：
    3. 为了保持数据一致性，任何修改都会全量更新数据

11. 自研图形引擎Design Graph
    
    历史问题：Mdesign3使用MXGraph，图形扩展难度大、性能低、框架体积大、与业务绑定太深导致跨平台难度大
    
    Design Graph是独立组件，支持跨平台。Vue3响应式和svg结合绘制图形，向外导出graph类，抛出一些操作钩子，实现图形统一控制。

    缺点：
        1. svg在性能上表现较差，（canvas）
        2. 业务分离不明显，很多逻辑需要在多平台复写（monorepo）
    
    为什么不使用canvas：
        3. 不支持DOM事件绑定。
        4. 没有类似组件template的结构，使其维护起来不便，不利于抽象通用行为。

12. 技术引用（这里感觉不够详细，还需要进一步补充）
    
    JEST（https://github.yanhaixiang.com/jest-tutorial/basic/test-environment/#jsdom-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83）
    
    场景：快速迭代的时候，我负责软件中各个菜单功能，与其他开发人员交互频繁，导致我开发的一些功能在不知情的情况下被修改，所以引入JEST和HUSKY，代码push前会运行单测。

    解决了哪些问题：单元测试可以保证代码质量，避免已通过测试的功能被破坏。

    后续业务不能完全保证独立，可能影响多个已通过测试的功能，加上单测会使开发量增大。

    后续存在的问题：

    1. 开发流程不规范是主因，在此前提下追求测试覆盖率反而延长开发时间，尤其是对频繁改动的功能。
        1. 产品与功能不同步
    2. 业务混乱是次因
    3. 项目业务分离不明显，导致单测输入输出不可预知。同样不能测试驱动开发（TDD）
    4. 业务复杂，单测难度不亚于开发

    快照测试：先打印HTML结构保存起来，下次运行单测时同新的HTML对比

    静态Module处理：JEST不会和webpack产生交互

13. 简单说下node层

    软件分为四层，前端有UI层、Node层，层与层之间只能相互通信，不能跨层通信。Node层是中间层，主要用来处理图形交互、存储数据、处理项目文件。Node的加入主要是为了解决项目操作前进和后退的问题，其中一个概念叫step，意为执行步骤。具体实现为，前端每次请求都会进入事务，如果一次事务中存在修改数据的操作，会将其插入step表中用于前进后退，每行step数据中有一个change字段，用于记录新增、删除和更新操作的内容。如果是一次操作多个事务，会通过stepId更新change字段。

    删除通过修改isDelete字段实现

    更新相当于拷贝原来数据、然后删除、然后新增。

    分段处理数据，需要保存事务状态。然后修改事务中数据的变更。

    其实对前端来说，这一层很多余。前后端是链式请求的，node层积累大量中间接口。因为业务的特殊性，Node层和后端是单线程的。再者很多开发人员没有接触过后端，开发不是很规范。整个Node层代码很混乱。且前端没有对node进行分层，而是前后端都写。大部分人对ui层更熟悉，node代码很混乱。因为是核心工具，其他项目组成员有时也会来上手代码进行对应项目交接。


14. 性能优化

    1. 接口优化
        1. 统一接口范式：所有请求改为复数
        2. Node层合并处理结果

            如果不声明立即返回数据，默认合并处理结果：时间过期、遇到错误、遇到立即返回结果的接口，会将缓存内容推送出去再清空。

        3. 缓存请求结果
        4. 交互优化：长接口自动loading。
    2. Node层数据处理优化
        1. 切割处理数据：如果标注是无关联的数据，会切割数据分开处理
        2. 数据库层级数据请求优化：单次请求会根据文件id获取所有元素，然后拼装成树

            缺点：只适合无关联性，且数据量小，跟业务绑定紧密

        3. 优化代码逻辑：递归转为迭代，层级迭代降低层级，深度遍历及时剪枝。

    3. 渲染优化
        拆分样式表、提升图层、使用will-change告诉浏览器提前优化
        降低坐标精度：坐标使用整数方便数据I/O，且能提升SVG渲染速度
        移除组件内css style，改为内联样式和全局样式。
        减少插槽的使用。
        SVG中使用path绘制内容：使用rect这样需要创建多个对象，path可以一笔带过

15. Design Graph跨平台

    因为Graph主要由MD项目组维护，且版本号更改频繁。其他项目组使用时交接困难。不适合通过组件的方式引用graph。其他项目组没有模型解析服务，需要单独维护一个服务用于graph数据解析。

    所以采用iframe加载graph

# 有什么想问面试官的

1. 产品研发的流程
2. 现有项目开发中，前端有架构师介入吗？架构师应该在项目中扮演什么样的角色。
3. 开发团队中有技术分享吗？
4. 对我今后学习方向有什么建议？

# 作为前端负责人主要做哪些工作

1. 资源协调：协调组内资源有效利用
2. 任务分配：根据不同人员的能力情况，进行任务分配
3. 技术分享：code review的时候给成员方案做一些指导意见，定期举行技术分享会分享近期热点技术
4. 需求审核：保证任务输入合理
    1. 很多时候由于各种原因会导致硬编码的存在，这个时候需要枚举相似需求，保证功能抽象解决硬编码问题。
5. 技术实施：前往实施一线解决客户问题，并反馈研发

# 如何避免自己成为团队效能瓶颈

1. 需求评审时引导成员向已完成任务思考，产生需求上下文，形成owner意识
2. 让成员定期主持技术分享会

# 如何实现国际化

完整流程：每次版本发布前，产品组会提供给研发一份翻译excel表并由研发人员编译校验成json格式并上传到内部术语库。编译时会根据key中的{}查看是否存在动态内容，并分类为基础内容和动态内容。翻译内容在打包时会使用本地化函数包裹。

1. 单词存在场景问题：固定单词词义（比如package直译是包，专业术语是包模型，有的时候还叫目录）
2. 动态内容替换问题：产品会使用`{}`标注动态内容，编译成json格式的时候会将内容分为基础内容和动态内容。
3. 翻译内容无缝切换：全局响应式。**会添加进度条交互，优先渲染可视部分。**
4. 校验
    1. excel编译为json的时候会做相似语句分析
    2. 前端打包阶段会执行本地化校验（脚本在术语库上维护），通过正则的方式匹配项目内文案，进行未命中分析。
    3. 后端提供预留接口可获取全部token，前端请求后进行token内容匹配，进行未命中分析。