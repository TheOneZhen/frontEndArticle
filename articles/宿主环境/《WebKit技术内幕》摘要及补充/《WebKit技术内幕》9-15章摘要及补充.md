《WebKit技术内幕》是我在知乎上**得到**的一本书，出发点源于自己的学习方向——前端跨端，一如Electron、Flutter这类框架。个人感觉这本书适合具有一定前端开发经验的读者，或者从事更底层开发（浏览器项目开发）的人阅读。同时此书中虽然列举了很多实践，但是明显与版本脱钩（书籍出版年限2014年），如果你有相关项目代码辅助阅读更好。然后我是在微信读书APP上购买了此书，链接[https://weread.qq.com/web/bookDetail/4b332350813ab7c27g013503](https://weread.qq.com/web/bookDetail/4b332350813ab7c27g013503)。

> 本篇（系列）文章只是对原文章作总结，有些内容虽然是直接摘抄下来的，但是不代表具备权威性（有些内容老旧），请读者斟酌。
>
> 本篇（系列）文章相较于原文忽略了很多内容，比如实践（代码）、前端开发基础内容等，建议读者将本文做为二手阅读。

# 第九章 JavaScript引擎

## 9.1 概述

JS是动态类型、**解释型**语言（这种概况不太准确，比如在V8的实现更偏向于编译型语言），一般作为脚本运行在WEB环境。对于C++这种强类型编译型语言，在属性访问时，C++依据对象地址以及初始size字节便可访问对象属性，而JS则类似需要通过字符串匹配才能访问属性，存在巨大性能差异。为了弥补性能问题，JS引擎的诸多实践中引入了JIT技术（Just In Time），该技术会将JS直接编译为本地代码（机器码），大幅度提升性能。

JS引擎包括以下几个部分：

- 编译器：将源代码编译成抽象语法树；
- 解释器：接受字节码然后解释执行，依赖垃圾回收机制；
- JIT工具：将字节码或抽象语法树转换为机器码；
- 垃圾回收器和分析工具（Profiler）：负责垃圾回收和收集引擎中的信息，帮助改善引擎的性能和功效。

<img src="https://res.weread.qq.com/wrepub/CB_3300055433_255_1.jpg" alt="JavaScript代码的编译和执行过程" />

## 9.2 V8引擎

### 9.2.2 工作原理

V8中数据的表示分为俩部分：

- 数据实际内容：长度不固定，且内容类型不同，比如`String`、`Object`等；
- 数据句柄（handle）：包含指向数据的指针，除了极少数的数据类型比如`int`、`bool`类型存储在句柄中，其他类型都存储在堆中（因为长度不固定）。

V8首先使用解释器将**源代码**转变成**抽象语法树**，通过JIT编译器的全代码生成器(full code generator)从抽象语法树直接生成本地代码（机器码），所以没有像Java一样的虚拟机或者字节码解释器，这样做可以减少抽象语法树到字节码的转换时间。但是也存在一些缺点：

- 一些场景没有必要将JS转换为本地代码（机器码）
- 缺少源码到本地代码（机器码）的中间态，不同OS移植性维护成本高，比如Java在抽象语法树之后会编译成字节码以支持不同OS移植，然后使用解释器转换为本地代码（机器码）。

为了使JS能够在不同的操作系统运行，且本地代码（机器码）跟具体的硬件平台密切相关，V8使用了多个后端来生成对应的代码。虽然JIT技术太幅度提升了JS的性能，但是缺少中间表示层（字节码），导致性能没法进一步优化，V8在后续又做了很多大的变动：

- 延迟（deferred）：很多JavaScript代码的编译直到运行的时候被调用到才会发生，这样可以减少时间开销；
- 引入Crankshaft编译器

    Crankshaft编译器主要针对那些热点函数进行优化。该编译器基于JavaScript源代码开始分析，而不是本地代码（机器码）。

- 优化回滚（Deoptimization）

    Crankshaft编译器在优化时会优先假定变量类型不会变动，然后生成高效的本地代码（机器码）。如果变量类型中途发生改变，它会回滚到代码优化前的一般情况，这个过程会更低效。

- 隐藏类（Hidden Class）和内嵌缓存（Inline Cache）

    V8使用类和偏移位置思想，将本来需要通过字符串匹配来查找属性值的算法改进为使用类似C++编译器的偏移位置的机制来实现，这就是隐藏类。
    
    隐藏类之上还可以使用缓存来避免重复查询，也就是将之前查找的隐藏类和偏移值保存下来。当下次查找的时候，首先比较当前对象是否也是之前的隐藏类，如果是的话，可以直接使用之前缓存的偏移值，从而减少查找表的时间，即内嵌缓存。

V8管理分为俩部分：

- 内存分配
    - 堆内存

        V8使用堆来管理JavaScript使用的数据，以及生成的代码、哈希表等。

    - Zone Memory

        > 原文中介绍的是抽象Zone类，v8中为[Zone Memory](https://v8.dev/blog/optimizing-v8-memory#zone-memory-reduction)

        Zone Memory主要供内部虚拟机操作（Internal VM operations）使用，特点是每次申请都是一整块的（小）内存（Chunk），用完就全部释放，避免了对细微内存的管理。缺点是内存利用率低，如果存在程序长时间占用内存，会导致内存不足。

- 垃圾回收机制

    V8将堆分成三个部分，第一个是年轻分代，第二个是年老分代，其中还分成多个子部分，第三个是为大对象保留的空间。

    <img src="https://res.weread.qq.com/wrepub/CB_3300055433_272_1.jpg" alt="V8中堆的划分" />

    对于年轻分代，主要是为新创建的对象分配内存空间，因为年轻分代中的对象较容易被要求回收，为了方便垃圾回收，可以使用复制方式，将年轻分代分成两半，一半用来分配，另外一半在回收的时候负责将之前还需要保留的对象复制过来。对于年轻分代，经常需要进行垃圾回收。而对于年老分代，主要是根据需要将年老的对象、指针、代码等数据使用的内存较少地做垃圾回收。而对于大对象空间，主要是用来为那些需要使用较多内存的大对象分配内存，当然同样可能包含数据和代码等分配的内存，需要注意的是每个页面只分配一个对象。

V8引擎开始启动的时候，需要加载很多内置的全局对象，同时也要建立内置的函数，如Array、String、Math等。为了让引擎更加整洁，加载对象与建立函数等任务都是使用JS文件来实现的，V8引擎负责提供机制来支持，就是在编译和执行输入的JavaScript代码之前，先加载它们。V8引擎需要编译和执行这些内置的JS代码，同时使用堆等来保存执行过程中创建的对象、代码等，这些都需要较多的时间。为此，V8引入了快照机制。快照机制就是将这些内置的对象和函数加载之后的内存保存并序列化。序列化之后的结果很容易被反序列化，经过快照机制的启动时间，可以缩减几毫秒。在编译的时候打开选项“snapshot=on”就可以让V8支持快照机制。在V8中，mksnapshot工具能够帮助生成快照。快照机制同样也能够将一些开发者认为需要的JS文件序列化，以减少以后处理的时间，不过快照机制有一个非常明显的缺点，那就是这些代码没有办法被CrankShaft这样的优化编译器优化，所以存在性能上的问题。

## 实践——高效的JavaScript代码

理论上可以通过以下几种方法编写高效的JS代码，但是一般并不建议读者在语法性能上咬文嚼字（除非代码真的是屎记），相较于语法性能，网络带宽、外部依赖体积等因素更容易导致性能变差。

- 固定变量类型：JS类型是动态确认的，当类型发生改变时会触发优化回滚，产生额外的解析开销。
- 使用简单类型保存数据：简单类型的数据是保存在句柄中的，能够有效减少寻址时间和内存的使用。
- 优化内存使用：对于不需要使用的对象，可以直接将变量设置为空（`obj = null`）。对于属性，不建议使用`delete obj.a`来删除属性，因为这样会产生新的**隐藏类**，反而产生额外的操作
- 减少优化回滚
- 使用新机制：比如`requestAnimationFrame`等接口，并发处理代码，或使渲染和计算任务分离，大大提升引擎并发能力。

# 第十章 插件和JavaScript扩展

