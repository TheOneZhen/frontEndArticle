目录同这本书是完全合理的，但是接下来我要考虑的是读完这本书，我要获得什么以及向他人传达什么样的知识体系。但是由于个人学习前端不够系统，导致目前我无法清除读完这本过程中会发生什么，所以：
1. 首先读完上中卷
2. 然后在下卷去总结知识点
本篇将作为疑难知识点记录存在
希望之后有时间能把英文版阅读一遍，加深印象
<!-- ------------------------------------------------------------------------------------------------------------------- -->、
作者是以怎样的角度去分析js的，目前不得而知。在阅读过程中希望我能发现这个问题
<!-- ------------------------------------------------------------------------------------------------------------------- -->

1. 前端编译器感觉可以单独出篇文章
2. 作用域是一个单独的线程吗，在内核中是如何存在的（物理）？
   1. JE查询作用域？还是说作用域是单独的线程
   2. 作用域有多个吗，JE是如何进行调度的
3. 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定
   1. 这里和this不同
4. 函数声明和函数表达式的区别及应用
   1. 函数表达式变量名不会暴露给表达式所在的作用域
   2. 函数表达式写法（注意，这俩种写法在作用域提升方面有很大的不同）
      ```js
        // 自执行
        (function test() {...})()
        (function test() {...}())()
        (function () {...}())()
        // 通过变量的方式声明函数
        const a = function test() {} // 函数表达式不会暴露给a所在的作用域，所以外部访问test会ReferenceError
      ```
5. 块作用域
   1. if，for等
   2. try-catch
      1. 会形成单独的块作用域，
6. 对于`var a = 1`，其中定义声明`var a`是在编译阶段进行的，赋值声明`a = 1`在执行阶段进行
   1. 那是否可以延申
7. js与数据结构
   1. 从数据结构层面探寻js如何实现各种原理的（比如闭包，作用域）

<!-- 第一部分看完了，前面对内核的介绍挺感兴趣，后续的很多内容都是我接触过的，而且没有在浏览器（JE，编辑器）角度去介绍这些原理的实现，有点遗憾 -->

1. this是在运行时绑定的，不是在编译时，所以脱离了词法作用域
   1. 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到
   2. 上面这一点需要和DS结合起来
2. this的指向一般理解为调用函数的位置，实际上存在一些复杂场景
   1. 比如函数嵌套，this指向当前执行函数的上一个函数
3. 之前一直没有注意到严格模式，之后需要细究
   1. 严格模式下，this不会默认绑定全局作用域
4. 隐式绑定和隐式丢失
  ```js
  function foo() {      console.log( this.a ); }  
  var obj = {      a: 2,     foo: foo  };  
  var bar = obj.foo; // 函数别名
  var a = "oops, global"; // a 是全局对象的属性
  bar(); // "oops, global"
  ```
5. 构造函数
   1. **new只是一个语法糖，它会劫持它后面的第一个函数，并用构造对象的形式调用这个函数**
   2. 步骤
      1. 创建（或者说构造）一个全新的对象。
      2. 这个新对象会被执行[[ 原型]] 连接。（这一步还不详细）
      3. 这个新对象会绑定到函数调用的this。
      4. 如果函数没有返回其他对象，那么new 表达式中的函数调用会自动返回这个新对象。
6. 全局对象捕捉
   1. 对于需要进行绑定的方法，介错全局对象才是最好的办法
7. 键值范围
   1. .被称为属性访问
   2. []被称为键访问
   3. 对象中属性名永远都是字符串
      1. 如果不是字符串，会先被转为字符串（.toString()）
8. 拆分属性描述符
   1. writable，属性不可变，相当于定义了空的setter
9. 禁止扩展
   1.  Object.preventExtensions(..)
10. Object这块之后还需要再看一下
    1.  之后根据最新的英文版来看吧，这样可以补充ES6之后的标准
11. 对象属性的访问和词法有什么不同
12. get与reflect
13. for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值
    1.  本质是迭代器
14. mixin
15. 对于**构造函数A**来说，A.prototype.constructor是在声明时加上的属性。对于A的实例化对象objA来说，objA.constructor是执行时加上去的，
16. 类篇介绍时，应该更加具体的介绍我们进行兼容（扩展）时需要考虑的场景
17. **A instanceof B**含义：在对象A的整条原型链中是否有指向B的对象
<!-- 先假装上篇第5、6章读完了，因为这边的基础知识我差的太多，所以先继续中篇吧，最后根据下篇进行总结，在一个知识点上耗费太多时间显得固执 -->
<!-- 第二版以安排，之后需要对英文下手，建议由于中文版阅读，因为ES6之后也存在很多改动，避免知识体系混淆 -->
<!-- 中篇目录 -->
第一部分：类型和语法
第二部分：异步和性能
<!-- start the mid part -->
1. 浏览器如何处理多个\<script\>标签的  
   1. 不同script标签都是独立运行在global（or 'window' in web）
   2. 对于非异步标签，浏览器会从上到下执行\<script\>
   3. 不同\<script\>标签内部变量提升不会跨越标签
   4. 如果一个\<script\>标签内部发生错误，js程序会失败并停止，但是后续\<script\>不受影响继续执行
2. 为什么动态的向DOM中添加\<script\>标签，内部代码会被执行
   1. 这个取决于浏览器解析，个人推测为：浏览器解析DOM，发现\<script\>，将匹配到的字符串丢给解析器
3. 数字篇
   1. Number中位运算只对32位数有效
   2. 对NaN进一步介绍