# 作用域
这一篇内容有些多，涉及作用域、变量提升、闭包、柯里化以及偏函数，
作用域规定了查找变量的范围，js采用词法作用域（Lexical Scoping，静态作用域），即由当前执行的作用域一直向上查找，到全局作用域查找完全结束（此过程为作用域链），比如这段代码：
```js
var a = 1
function f1() {
  console.log(a)
}
function f2() {
  var a = 2
  console.log(f1())
}
f2()
```
```js
// 输出
1
```
执行f2的时候，f1执行时并没有在f2内部找a，而是在自己所在的环境向上找。
## [变量提升（Hoisting）](https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting)
JE执行代码之前，会扫描代码并将函数、变量的声明放入内存，使得可以在声明代码之前使用它们（非严格模式下），像下面这样：
```js
a = 10
console.log(a) // 10
var a
```
变量提升只能提升声明，不能提升赋值（初始化）：
```js
console.log(a) // undefined
a = 10
var a
```
### 为什么要机型变量提升
可以解决函数相互递归调用的问题（函数A调用函数B，但B未声明（缓存中找不到），此时引擎去找B声明（产生大量开销））
### 变量提升的坏处
影响代码可读性，
### 解决办法
先声明，再赋值使用
ES6介入
### 介入V8
- 生成抽象语法树
  - 词法分析
    - JE检测当前作用域下的所有变量和函数声明，并将这些声明添加到《词法环境》内存中
      - 对于变量声明（包括匿名函数和变量式声明函数），会为变量分配内存并初始化为undefined，赋值语句在生成机器码阶段真正执行代码的时候才进行
      - 对于函数声明，会在内存里创建函数对象，并且直接初始化（函数处理优先级高于变量，会更靠前）
    - 语法分析
  - 生成字节码
  - 生成机器码
    - 代码执行阶段（此时可以提前使用声明的变量，只不过值为undefined，函数可以直接调用）

# ES6
let、const是ES6新特性，用作声明时也会被提升，但是它们会形成暂时性死区（TDZ），在声明之前调用它们会报错
	let声明的变量如果没有赋初始值，在代码执行阶段会赋值为undefined
	const不赋初始值会报错

## 函数作用域
- 由此引申的函数执行步骤（存疑）：
	函数定义后（JE扫描后）：保存作用域链到函数特性[[Scopes]]
	函数执行后，先开始准备工作：创建函数执行上下文栈，相关函数变量入栈，复制函数[[Scopes]]特性创建作用域链
	开始函数执行：平平无奇的入栈出栈
	函数执行完成后：如果存在闭包，通过AST扫描闭包函数，打包闭包需要的资源，闭包函数入栈，原函数无效资源释放

# var、let、const区别

# 作用域链
- 静态作用域链（js设计）
  - 函数和块内的变量声明会在作用域（[[Scopes]]）内创建一个绑定（binding），其它地方对此绑定的引用的访问顺序
    - 与代码顺序强相关
  - 方便做静态分析（tsc、babel）
- 动态作用域链
  - 与执行顺序强相关

# 项目中将全部的var替换为let有什么风险，具体方案
1. 手动替换
2. Babel

# const定义的变量可以被修改吗，如何保证不可修改
1. Object.freeze()
2. TS as const

# 闭包
- 什么是闭包
  - 一个函数可以调另一个函数内的资源
- 闭包创建前后
  - 为了防止部分资源（引用型对象）缺少引用而被销毁，所以闭包之前会执行父函数资源的打包
    - 父作用域销毁不能影响子作用域，但是不销毁父作用域也不行，会造成严重的资源浪费，所以需要打包被调用的资源
    - JE会扫描函数内的标识符，把子作用域中引用的资源打包成Closure链（global链也会打包，俩者形成新函数的外部环境，以支持函数的运行），放到[[Scopes]]特性中
    - 对于eval，因为是动态内容，没法静态分析，所以打包时会打包整个作用域（eval + 闭包性能差的原因）
  - 打包后，JE销毁父函数中无效引用资源
- 资源如何打包
  - AST扫描，JE Lazy Parsing函数（闭包性能差的原因）
- 支持闭包的数据结构
  - [[Scopes]]
    - Closure
      - 存放子作用域引用的资源（闭包专属）
    - Global
      - 存放全局变量引用
  - 闭包类每次实例化都会生成一个单独的作用域，同源实例化变量之间的环境（数据）不会相互影响
  - 此结构为栈，因为闭包函数内部也存在无限调用
- 闭包保存在何处
  - 闭包生成前：存在于引用堆中
  - 闭包生成后：引用会入栈，闭包内新声明的资源会入堆，引用上下文资源的位置不变（堆）
- 闭包导致的内存泄露
  - 闭包函数调用的上下文资源没有使用且不及时释放
- 闭包实现私有函数和变量
> 私有函数：只能在类中被调用，无法在类外被调用
```js
const counter = (function () {
    let count = 0
    function change(val) {
        count += val
    }
    return {
        increment: function () {
            change(1)
        },
        decrement: function () {
            change(-1)
        },
        value: function() {
            return count
        }
    }
})()
```
## 闭包应用
- 柯里化
  - 柯里化复杂了函数执行，但是提高了函数的适用性
  - 实现
    ```js
        function curry (fn) {
            return function curried (...args) {
                if (args.length >= fn.length) {
                    return fn.apply(this, args);
                } else {
                    return function (...args2) {
                        return curried.apply(this, args.concat(args2))
                    }
                }
            }
        }
    ```
  - lodash实现
    ```js
    ```
- 偏函数
  - 函数在调用的时候，不用传入全部函数（部分参数细节被隐藏）
  - 实现
    ```js
    function list() {
        return Array.prototype.slice.call(arguments)
    }
    const mid = list(undefined, 10)
    mid() // [10]
    mid(1, 2, 3) // [10, 1, 2, 3]
    ```

## Q&A
- "use strict"是怎样限定变量调用的
- 面试题
  ```js
    var foo = 5
    function hoist() {
        console.log(foo) // function foo() {}
        foo = 3
        console.log(foo) // 3
        function foo() {}
    }
    hoist()
    console.log(foo) // 5
  ```
## 引用
1. https://juejin.cn/post/7210614375290863673
2. https://zhuanlan.zhihu.com/p/121558249
3. https://juejin.cn/post/6957913856488243237
4. https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md
5. https://towind.fun/2021/05/10/js-hoisting/
6. https://fangyinghang.com/let-in-js/